```
	2021年9月16日13:23:37创建
```

# 目录

[TOC]

# DataStructure

## 数据结构的背景

```
	
	计算机 不再局限于科学计算 更多的用于控制 管理 数据处理
	为了编写好程序 必须分析 待处理对象的特性 和 处理对象之间的关系
	解决问题方法的效率和数据的组织方式有关
	
```

## 什么是数据结构

```

	用计算机解决一个具体问题
		从具体问题中抽象出一个数学模型 设计一个解此数学模型的算法 最后编出程序 调试测试得到最终解答
		寻求数学模型的实质是分析问题 从中提取操作的对象 找出操作对象之间的关系 用数字的语言加以描述
	
	但是有一些问题不能用 数学的公式或者方程来描述 是 非数值计算 的程序设计问题
		描述非数值计算问题的数学模型 是诸如 表、树、图之类的 逻辑关系数据
		
	数据结构 研究 非数值计算的 程序设计问题中 计算机的操作对象 以及它们之间的 关系 和 操作 的学科
	
```

## 基本概念和术语

### 数据

```
	
	信息的载体
	对客观事物的符号表示
	指 所有 能 输入 到计算机中 并可被 计算机程序处理 的符号 的总称
	
	包括 
		数值型的数据 整数 实数 等
		非数值型的数据 文字 图像 图形 声音 等
	
```

### 数据元素

```
	
	数据的基本单位 在计算机程序中通常作为一个整体 考虑 处理
	一个数据元素 由若干个 数据项 组成 (数据项 是 数据的不可分割的最小单位)
	也简称 元素 记录 结点 顶点
	
```

### 数据对象

```
	
	性质相同  数据元素 的集合 
	数据的子集

```



### 数据结构

```
	
	互相之间 存在 一种 或 多种特定关系 数据元素的集合
	数据结构是 带结构的 数据元素的集合
	
	数据结构包括
		数据元素 之间的 逻辑关系 也称为 逻辑结构
		数据元素 的关系 在计算机内存中的表示(又称为映像) 称为数据的物理结构(或储存结构)
		数据的 运算和实现 对数据元素可以施加 的操作 及操作在 储存结构上的实现
		
```

#### 数据结构的形式定义

```
	
	数据结构是一个 二元组 
	Data_Structure = ( D , S )
		D 是 数据元素的 有限集
		S 是 D上关系的 有限集
		
	结构定义描述的关系 是 数据元素之间 的 逻辑关系 因此又称为 逻辑结构 
	
```

#### 数据结构

```

	数据结构 在计算机中的表示(又称 映像) 称为 数据的 物理结构(又称 存储结构)
		计算机表示信息的最小单位是二进制数的一位 叫做 位(bit)
		可以用若干位数的位串表示一个数据元素(如 一个字长的位串表示一个整数 8位二进制数表示一个字符)
			通常称这个 位串为 元素(element) 或 结点(node) //元素或者节点可以看成是 数据元素 在计算机中 的映像
			当数据元素 由 若干的数据项组成时 位串中 对应于各个数据项的子位串 称为 数据域
	
```

#### 存储结构

```
	
	存储结构是 逻辑关系的 映像 与 元素本身的 映像   是 数据结构的实现
		
	物理结构(存储结构) //在计算机中
		数据元素 及其关系 在计算机 储存器 中的结构(储存方式)
	
	数据元素之间关系 在计算机中 有两种不同的表示方法
		顺序映像(顺序存储结构) 和 非顺序映像(链式存储结构)
		顺序映像 借助元素在 储存器中 的相对位置 表示 数据元素之间的 逻辑关系
		非顺序映像 借助指针(指向元素存储地址) 表示 数据元素之间的 逻辑关系
		
	顺序存储 将数据元素存放在一片相邻的连续区域 操作时需要大量移动元素
	链式存储 节点中存储元素信息 不占用连续存储单元 只对指针操作便于增删
	
```

### 逻辑结构

```
	
    逻辑结构 //逻辑规律
        逻辑结构是 数据结构的抽象
        描述 数据元素 之间 的逻辑关系
        与数据的储存 无关 独立于计算机
        从具体问题 抽象出来 的数学模型
        
    
    数据元素不是孤立存在的 它们之间存在关系 这种关系称之为结构
	
	结构根据关系基本可以分为 
		集合 
			数据元素之间 同属于一个集合无其它关系
		线性结构
			数据元素之间 存在一对一关系
		树形结构
			数据元素之间 存在一对多关系
		图状结构或网状结构
			数据元素之间 存在多对多关系
			
		两种 线性结构 非线性结构(树形结构 图状结构或网状结构)
		三种 线性结构 树形结构 图状结构或网状结构
	
```

### 算法

```
	
	是对特定问题 求解步骤 的 一种描述
	算法的设计取决于 选定的数据(逻辑)结构 算法实现 依赖于采用的储存结构
	
```

#### 算法特性

```
	
	有穷(有限指令集) 确定 可行 输入 输出
	
```

#### 一个好的算法

```
	
	正确性	//程序对于精心挑选的典型苛刻的 几组数据 能够满足 规格说明要求的结果
	可读性
	健壮性 输入非法值 算法也能适当做出处理
	效率与低储存量需求
	
```

#### 算法的度量T(n)

```
	
	算法执行的时间 按 算法编写的程序 在计算机上 运行消耗的时间 来度量 通常有两种方法
		
		算法在计算机上的运行取决于 算法的策略 问题的规模 语言的级别(越高效率越慢) 编译程序产生的代码质量 机器执行指令的速度
	
		事后统计法	
			//通过计算机记时功能 通过测试一组或多组数据 (速度太快看不到可以多取几次求平均) 
			//需要运行程序测试
			//受到计算机硬件软件环境影响 容易掩盖算法本身优劣 
			
		事前分析估算的方法
			//算法运行收到各种因素影响 使用绝对时间衡量 算法的效率是不合适的 
			//一个算法 有控制结构(顺序 分支 循环三种) 和 原操作(固有数据类型的操作) 算法时间取决于两种综合效果
			//通常 从算法选取一种 对于算法解决问题 是基本操作的原操作 以该基本操作重复执行 的 次数作为算法时间量度
		
		一般 算法 基本操作重复执行的次数 是 问题规模n 的某个函数 f(n) 所以算法的时间量度 记作
			T(n) = O(f(n)) //随n的增大 算法执行时间的增长率和f(n)的增长率 相同 称作算法的 渐进时间复杂度 简称 时间复杂度
		被称作 问题基本操作的 原操作 应时 其重复执行次数 和 算法的执行时间成正比的 原操作 通常情况下 它是最深层循环 内的语句中的原操作 它的执行次数和包含它的语句的频度相同
		频度 指 该语句 重复执行次数
			
			{++x;}; 常量阶 频度为1 时间复杂度为O(1)
			for(i=1;i<=n;++i){++x;} 线性阶 频度为n 时间复杂度为O(n)
			
			for(i=1;i<=n;++i) 平方阶 频度为n平方 时间复杂度为O(n平方)
				for(i=1;i<=n;++i){++x;}
				
			//还有呈现时间复杂度为 对数阶O(log n) 指数阶O(2的n次方)
		
		
		一般 对一个算法 选择 一种基本操作 讨论算法 的时间复杂度 
		有时候也需要同时考虑多种操作 可以对不同操作赋予不同权值 常用语综合比较统一问题两种完全不同的算法
		气泡排序算法的复杂度为O(n的平方)
		根据输入操作集出现 的概率难以确定 则可以 只讨论最坏情况下的时间复杂度
		也可以事前和事后两种方法结合起来 估算时间
			
```

#### 算法的存储空间需求S(n)

```
	
	算法所需存储空间的量度	S(n) = O(f(n)
	
```

### 数据类型

```
	
	数据类型 明显或隐晦的规定了 在程序执行期间变量或表示所有可能取值的范围 以及在这些值上允许进行的操作
	是 一个值的集合 和 定义在这个值集上的 一组操作 的总称 
	硬件上解释计算机 内存 中信息含义的一种手段 对用户一种封装的手段 让用户只抽象关注于数学计算 
	
```

### 抽象数据类型(ADT)(Abstract Data Type)的形式定义

```
	
	抽象 数据类型 和 数据类型 实质上 是一个概念
	指 一个数据模型 以及 定义在 该模型上的 一组操作 
	
	抽象数据类型 用三元组 表示
        (D, S, P)
            D 是 数据元素的 有限集
            S 是 D上关系的 有限集
            P 是 对D的 基本操作集
            
    抽象 描述数据类型的方法 不依赖与具体实现
    	与 存放数据 的机器无关
    	与数据存储 的物理结构无关
    	与实现操作的 算法和编程语言无关
         
```

#### 笔记表示

```
	
	ADT 抽象数据类型名{
  		数据对象
  		数据关系
  		基本操作
  	}ADT 抽象数据类型名
  	
  	//数据对象 关系 用 伪码 描述
  	//基本操作的定义格式为
  		基本操作名(参数表) 
			初始条件
			操作结果
		//有两种参数 赋值参数(只为提供输入值) 引用参数(&传递地址 用于提供输入值和返回结果)
		//初始条件 说明 执行操作前需要满足的条件 不满足操作失败返回信息
		//操作结果 说明 操作完成后数据结构 的变化状况和返回结果
	
```

### C和C++一些核心语法(用于实现数据结构)

#### 预先引用

```
	
	#include <stdio.h>
	#include <stdlib.h>
	//引用一些 工具函数类
	
```

#### 预定义常量和类型

```
	
	// 定义状态码
    #define OK 1
    #define TRUE 1
    #define FALSE 0
    #define ERROR 0
    #define INFEASIBLE -1
    #define OVERFLOW -2
    
    // 定义函数类型 其值为函数结果状态码
	typedef int Status;
	
```

#### 数据结构的表示(存储结构)

```
	
	用类型定义typeof描述
	数据元素类型 约定为 Elem Type 由用户在使用该 数据类型时 自行定义
	
```

#### 基本操作算法的函数描述

```
	
	Status(函数返回类型) 函数名(函数参数表){
		语句
		return 返回值;
	} //注释
	
	//如果没有返回值 则Status 可 写为void
	
```

#### 注释

```
	
	// 单行注释
	/**/ 区块注释
	
```

#### 引用参数

```
	
	增添了C++ 引用调用 参数传递 形参表 中以&表示	//因此编写测试程序需要 将后缀名改为.cpp 使用& c语言中没有&

```

#### 输入和输出语句

```
	
	scanf([格式串],变量1,变量2..);
		//scanf("%d",&e); 用户输入的值 赋值给变量e
	printf([格式串],变量1,变量2..);
		//printf("元素为%d\n",e); 输出变量e的值 结果 元素为e
	
```

#### 逻辑运算符

```
	
	与运算符 && A&&B A的值为0时 不再对B求值
	或运算 || A||B A的值为非0时 不再对B求值
	
```

#### 函数

```
	
	malloc()	//动态的分配 指定大小 内存空间 成功返回内存地址 失败返回NUll
	sizeof()	//返回一个对象 或 类型 所占的内存字节数
	free()	//释放malloc函数 申请的空间
	
```

#### 赋值 选择 循环 结束语句

```
	
	变量类型 变量名 = 条件表达式 ? 表达式1 : 表达式2;
	
	if else
	
	switch(表达式){case 值:语句序列; break; case... default}
	
	for for(赋初值表达式;条件;步长){语句;}
	for for(赋初值表达式;条件;步长)语句; //一句可省略{}
	
	while(条件表达式){语句;}
	do{语句;}while(条件表达式);
	
	异常结束语句 exit(异常代码);
	
```



### 杂乱定义

#### 多形数据类型(polymorphic data type)

```
	
	指 其值 成分 不确定的 数据类型 
		//但是不论元素 有何种特性 元素之间的关系相同 基本操作也相同 从抽象数据类型的角度看 具有相同的数学 抽象特性
		//就像数组 存储的数据元素类型 可以为任意类型 
	
```

## 线性表

### 线性表定义

```
	
	n(n>=0) 个元素的有限序列
	同一线性表中的元素 必须 属于 同一数据对象
	由若干个数据项 组成的数据元素 称为记录
	含有大量记录的线性表又称为文件
	线性表 中元素的个数 定义为线性表的长度 个数为0 为空表
	
```

#### 抽象数据类型

![](Images\数据结构\Snipaste_2021-12-19_21-19-12.jpg)

```
	
	//ElemSet 为数据元素类型
	//操作省略 还有更 复杂的操作 线性表拆开成两个或两个以上的线性表
	
```

#### 线性表的逻辑结构

```
	
	 在数据元素的 非空有限集中 
		存在 唯一 一个被称作 第一个 的数据元素
		存在 唯一 一个被称作 最后一个 的 数据元素
		除了第一个 每一个元素均有一个 前驱
		除了最后一个 每一个元素均有一个 后继
	
	数据元素 都有确定的位置 即位序
	比较灵活的 数据结构 长度可以根据需要 增长 缩短 遍历 插入 删除
	
```

#### 线性表的存储结构

##### 顺序表(顺序存储)

```

	概念 用 一组 地址连续的 存储单元 依次 存储 线性表的数据元素
	特点 元素顺序存放 相邻元素通过内存地址产生联系 确定存储的起始位置 后 可以实现随机存取(可以访问任意位序的数据元素)
	表示方式 通常使用数组描述数据结构中的 顺序存储结构 //因为数组类型也随机存取
	
```

```
	
	假设 
		线性表 每个 元素需要 l 个存储单元 
		并且以占的第一个单元的存储地址 作为数据元素的储存位置 
	
	则有以下关系 //LOC()为存储地址 LOC(a下标1)为初始地址(基地址)

```

$$
根据第i个元素的存储位置求第i+1个数据元素的储存位置\quad LOC(a_{i+1})=LOC(a_i)+l
$$

$$
通用一般公式为\quad LOC(a_i)=LOC(a_1)+(i-1)*l
$$

###### 顺序表的插入

```
	
	一般情况下 在第i个元素之前 插入一个元素时 需要将第n至第i 共 (n-i+1) 个元素向后移动一个位置
	
```

###### C语言实现(.cpp)

```c++
	
	#include <stdio.h>
    #include <stdlib.h>

    //定义状态码
    #define OK 1
    #define ERROR 0
    #define OVERFLOW -2

    //定义函数类型 其值为状态码
    typedef int Status;
    typedef int ElemType;

    /*定义线性表的存储结构*/
    #define LIST_INIT_SIZE 100 //空间初始分配量
    #define LISTINCREMENT 10 //增量大小
    typedef struct{
        ElemType *elem; //储存空间基址
        int length; //长度
        int listsize; //当前分配的储存容量(sizeof(ElemType)为单位)
    }SqList;

    //遍历顺序表
    void PrintList_Sq(SqList L){
        int a;
        printf("线性表内容为\n");
        for(a=0;a<L.length;a++){
            printf("%d",L.elem[a]);
        }
        printf("\n");
    }

    //初始化函数
    Status InitList_Sq(SqList &L){
        L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
        //存储分配失败
        if(!L.elem) exit(OVERFLOW);
        L.length = 0;
        //初始存储容量
        L.listsize = LIST_INIT_SIZE;
        return OK;
    }

    //向线性表的元素i前插入一个元素 指针法
    Status InsertList_Sq(SqList &L,int i,ElemType e){
        if(i < 1 || i > L.length + 1) return ERROR;//i值不合法 i取值范围为 1<=i<=length+1
        //存储空间已满 增加存储空间
        ElemType *q,*p;
        if(L.length >= L.listsize){
            ElemType * newbase = (ElemType *)realloc(L.elem,(L.listsize + LISTINCREMENT)*sizeof(ElemType));
            if(!newbase)exit(OVERFLOW);//存储分配失败
            L.elem = newbase;//新基址
            L.listsize += LISTINCREMENT;//增加存储容量
        }
        q = &(L.elem[i-1]);//q为插入位置
        //for循环体只有一句可以省略{}
        for(p = &(L.elem[L.length-1]);p >= q;--p)* (p + 1) = *p;
        *q = e; //插入e
        ++L.length; //表长增1
        return OK;
    }

    //删除
    Status DeleteList_Sq(SqList &L,int i,ElemType &e){
        ElemType *q,*p;
        if(i < 1 || i > L.length + 1) return ERROR;//i值不合法
        p = &(L.elem[i-1]); //删除元素的指针位置
        e = *p;
        q = L.elem + L.length - 1;
        for(++p;p<=q;++p) *(p-1) = *p; //被删除元素之后的元素左移
        --L.length;
        return OK;
    }
	
```

##### 链表(链式存储)

```
	
	概念 除了存储数据 还要存储其相邻元素的 存储位置 两者组成结点 n个结点链结成链表
	特点 元素在内存 中随意位置存储 通过依次遍历元素保存的 相邻元素的内存地址 实现 顺序存取
	表示 存储数据信息的域为数据域 存储位置的域为指针域
		根据指针 存储信息 不同链表 可以分为
			单链表	每个节点中保存后继元素地址
			循环列表 头尾相接的单链表 使单链表形成一个环
			双向链表 即保存前继元素位置 又保存后继元素位置 有两个指针
			静态链表 使用数组描述指针
	
```

















