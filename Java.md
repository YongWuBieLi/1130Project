```
	
	2018年11月29日11:12:53开始创建
	2022年3月1日20:57:52 - 2022年3月17日17:58:55 精细调整
	2022年3月29日16:12:46 全部重写 缩减已用不到的
	2022年6月16日11:02:10 - 2022年6月16日16:05:10重写
	2022年6月16日16:05:18 - 2022年6月17日14:10:05增添
	
```

# 目录

[TOC]

# Java

## 简写表

```
	
	Java > J
	
```

## J基本介绍

### 什么是程序

```
	
	为了让 计算机执行 某些操作 解决问题 编写的 有序指令 集合
	
	程序=数据(属性)+算法(方法)
	
	程序的 主要任务 是 操作数据完成 业务
	
```

### J发展史

```
	
	Sun公司1995年 面向对象程序设计语言
	詹姆斯 高斯林 
	最初名字为OAK(树) 
	1995重命名为Java(爪哇岛盛产咖啡)
    2009被甲骨文收购
	
```

### J版本

```
	
	Java SE Java的标准版 是JAVA的基础 另外两个领域都以这个为基础 桌面应用软件
	Java EE Java的企业版 面向企业应用 (占有量高) 分布式的网络程序的开发
	Java ME Java的微型版 手机、掌上电脑 (占有量很少)
	
```

### J特性

```
	
	面向对象 简单 解释性 分布性(分布式处理) 多线程 可移植 动态 高性能 健壮性 安全性(面试时不要说)
	
	可移植 - J程序可以在任何计算机、操作系统和支持Java的硬件设备上运行 
	
```

## JRE与JDK

```
	
	安装百度
	
	JRE(Java Runtime Environment) 运行环境 主要负责程序运行
		包括JVM虚拟机 只运行开发好的程序 安装JRE就好 
		JVM+类库
	
	JDK(Java Development Kit) 开发环境
		包含了JRE
		包含了开发所需编译 调试工具 JDK源码
		JRE+JAVA开发工具
		
	安装文件中
		bin 存放一些可执行程序
	 	lib Java类库或者库文件
	
```

### JDK命令行

```
	
	java 启动JVM执行class
	javac Java编译器
	jar Java打包工具
	javadoc Java文档生成 //开发工具也可以生成javadoc
	
```

### J编译运行过程

```
	
	.java 
		经过编译 //javac编译源文件
			字节解码文件 //.class
				JVM运行
					字节码文件 //java命令启动JVM
	
```

## IDEA

### 快捷键

|                  按键                  | 作用                         |
| :------------------------------------: | ---------------------------- |
|              psvm + Tab键              | main方法主体                 |
|             sout  +  Tab键             | 输出语句                     |
|          InsSckLk键 +  Alt键           | 实现各种方法的选单           |
|         Shift键 + Ctrl键 + A键         | 输入setb更换背景图片         |
|           Ctrl键 + Alt键 + T           | 使用某个语句包围括起来的部分 |
| Shift键 + Alt键 + 鼠标选择 or 鼠标中键 | 选择多行进行编码             |
|           Ctrl键 + Alt键 + L           | 代码格式化 规范              |

## 规范

```
	
	//阿里巴巴Java开发手册 一切以此为最高遵循规范
	
	空行
		//括号要对齐 成对写
		//方法和程序块 运算符两侧 加空行更清晰 
		//多行空格无意义
		//代码和注释 应该有 机构性的整体对称布局
	 
	规定
	 	//Java对大小写敏感
		//语句都以";"结束
	 
	尽量
	 	//一行只写一行语句
		//没用的注释不要写
	
	建议
		//正确使用变量的有效范围节省内存资源
		
	变量名命名规范
		//必须以 字母 $ _ 开头
		//可以包括数字 但不能开头
		//除 $ _ 不能有其它特殊字符(空格也不行)
		//不能用Java关键字
		//变量名可为汉字或其他语言文字(但不要这样写)
		//简短 清楚表明作用
		//通常 大驼峰命名 或 小驼峰命名
			
```

## J基础语法

### 注释

```
	
	单行注释 只能注释一行
		//	
		
	多行注释 可跨多行 
		/* 注释内容 */  
	
	文档注释 主要注释一些对象和方法 最后可以生成相关Doc文档
		
		/**
		* 注释内容
		* 注释内容
		*/
	
```

### main方法

```
	
	//一整个.java 文件
	
	package com.test.staticA; //包

    public class A {
    	//main方法
    	public static void main(String[] args) {
			/*语句块*/
    	} 
    }
	
```

### 输入(出)语句

```
	
	//输入
		Scanner in = new Scanner(System.in);
		
        int a = in.nextInt(); //接收整形类型方法
        float b = in.nextFloat(); /接收浮点方法
        String s = in.next(); //接收字符串方法
	
	
	//输出
	System.out.println(值);
		//无论任何类型都自动转为字符串进行打印
		//数字可以直接输出 
		//没有确定类型的数会自定 整数为int 小数点为double
		//null 不能直接输出
		//继承祖先类Object toString()方法 输出时默认调用toString 将参数转换为字符串输出 可以将祖类的toString方法重写 之后使用输出语句 就会返回重写的内容 不是对象 的内存地址
	
```

### J数据类型

```
	
	数据类型分为两类 基本数据类型 和 引用数据类型
	
	基本数据类型
		数值型 //包含 整数类型 浮点类型 字符型
		非数值型 //包含 布尔型
	引用数据类型
		类	//class
		接口 //interface
		数组 //[]
	
```

#### 8种基本数据类型

```
	
	8位等于1字节 == 8bit = 1B
	
```

|  类型   | 字节大小 | 位数 | 初始值(默认值) |      取值范围      | 二进制位数 |
| :-----: | :------: | :--: | :------------: | :----------------: | :--------: |
|  byte   |    1     |  8   |       0        |     -128 ~ 127     |    Byte    |
|  short  |    2     |  16  |       0        |   -32768 ~ 32767   |   Short    |
|  char   |    2     |      |   \u0000(0)    |      0~65535       | Character  |
|   int   |    4     |  32  |       0        |     -2^31~2^31     |  Integer   |
|  long   |    8     |  64  |       0        |     -2^63~2^63     |    Long    |
|  float  |    4     |  32  |      0,0       | -3.403E38~3.4.3E8  |   Float    |
| double  |    8     |  64  |      0,0       | -1.978E308~4.9E324 |   Double   |
| boolean |   1/8    |      |     false      |    true、false     |  Boolean   |

#### 数值类型 

```
	
    byte  
    short	
    int  
    long //声明时 必须在末尾加上L 大或小写

    //整数类型默认 int System.out.println(25/10); //2
    //byte 和 short 参与运算 类型自动提升为int 
        
```

#### 浮点类型

```
	
	//浮点型不精确  java.Math包 BigInteger和BigDecimal 是精确类
	 
	float 声明时 必须在末尾加 大或小写F 
	double 声明时 非必须加大小写D
	   		 
	浮点类型默认 double System.out.println(25.0/10); //2.5
	
```

#### 布尔类型

```
	
	boolean 只有两个值true 和 false
	//可以直接输出 System.out.println(true); //true
	
```

#### 字符类型

```
	
	char 存储一个字符  要用('')括起来 或者 是unicode码 //(a的un码为97)
	
	//char在转换上 只用于拼接 或 按照Unicode转换成数值 
	//char b ='a';  int a = (int)b; //a=97
	//char 参与运算 使用该字符的编码 0+'0'=48
	
```

### 声明变量

```
	
	//声明一个变量就是在内存空间划出一块合适的空间
	
	变量的组成  数据类型 变量名 = 变量值 ;
	
```

```
	
	边声明边赋值	
		//int A = 5;
	先声明再赋值 
		//int A; A = 5;
	一次声明多个变量 
		//int A,B,C,D = 5;
		//int A=1,B=2,C=3;
	
```

```
	
	//注意不要超过该类型的取值范围
	//变量的作用域出错
	//赋值 值类型错误
	
```

#### 声明常量

```
	
	常量的组成 final 数据类型 常量名 = 变量值 ;
	
	//常量值 是固定的不可更改
	//定义 必须在一条语句中完成声明和赋值
	//变量名经常全部大写 多个单词也全大写(并用_隔开)
	
	一般的定义形式为 static final 类型 常量名 = 常量值;
	
```

### 类型转换

```
	
	(byte、short、char)----->int----->long----->float----->double
	//char在转换中的位置不一定
	
	类型转换 方式有以下几种
		低级 到 高级的自动类型转换
		高级 到 低级的强制类型转换(可能会导致丢失精度)
		基本类型 向 类 类型转换(包装类)
		基本类型 向 字符串转换(.toString())
		类 向 字符串转换
	
```

### 变量作用域

```
	
	//变量声明的位置 决定 变量作用域
	
	分 全员变量(成员变量) 和 局部变量
	
		全局变量声明在类体中 使用时 非必须 设初始值 不给自动为默认值
		局部变量声明在方法体中	使用时 必须要给初始值 不赋值使用编译报错
	
	
	//同一个类中 成员变量 和 局部变量同名 局部变量具有更高的优先级
	//在同一个方法中 不允许有同名局部变量 for循环等除外
	//在不同的方法中 可以有同名局部变量
	
```

### 变量之间的运算符

```
	
	//在编写程序时尽量使用括号 限定运算顺序 以免发生错误 运算 
	
```

#### 赋值运算符

```
	
	"="		将等号右边表达式的结果 赋值给 等号左边的变量
	
```

#### 算数运算符

```
	
	"+"   "-"   "*"   "/"   "%"
	
	//先乘除后加减 有取余 则 从左往右 计算
	//在进行除法运算时0不能做除数 没有意义
	//两个两个以上的数据类型运算 结果是优先级最大的
	
	//System.out.printl(1+2+"3"+1)输出结果为331)
	//System.out.println("5+5="+5+5);的结果为5+5=55
	
```

#### 比较运算符

```
	
	"<"   "<="   ">"   ">="   "=="   "!="
	
	//封死值域
	//"==" 比较运算符比较的是两个字符串的地址是否相同
	
```

#### 自增自减运算符

```
	
	"++"   "--"
	
	相当于a=a+1; 或者a=a-1; 可以有这种格式的a+++--i
	
	++A，A++的区别
	;
	  int A = 0;
	  int B = 0;
	  int C = 0;
	  ++A；//此时A=1;
	  System.out.println(A);//结果为1
	  C=B+A++；//此时计算的是 C = 0+1++;
	  System.out.println(C);//结果为1
	
```

#### 逻辑运算符

```
	
	"&&"   "||"   "!"   "^"
	
	//"&&"且 几个条件一起满足才true
	//"||" 与  几个条件中有一个满足就true 短路与 左边的条件为false右边不执行 左边为true右边必执行
    //短路或 左边为true右边不执行 左边为false右边必执行
	
	"&"  和  两个都为true才是true 两边都要执行
	"|"  或  有一个是true就是true 两边都要执行
	"!"  非  与之相反的结果 !true =false
	"^"  异  两个值相同为false 两个值不同为true
	
	/一个数对另一个数据位 异或两次,该数本身不变
	
```

#### 三元运算符

```
	
	条件表达式 ? 值1 : 值2  条件表达式为真取值1  相反取值2
	值1和值2可为任何值
	使用三元运算符的好处可以使代码简介并且有一个返回值
	三元运算符可以有很多骚操作 值1值2可以 可以为get方法的调用  (待补充)
	
```

#### 扩展赋值运算符

```
	
	"+="  A += B  	等效的表达式 A=A+B
    "-="  A -= B	等效的表达式 A=A-B
    "*="  A *= B	等效的表达式 A=A*B
    "/="  A /= B	等效的表达式 A=A/B
    "%="  A %= B	等效的表达式 A=A%B
	
```

#### 优先级

```
	
	括号 → 正负号 → 自增自减运算符 → 算数运算符 → 移位运算符  → 比较运算符  
	  → 逻辑运算符 → 赋值运算符
	
```

### *常量池与堆

```
	
	常量池 
		//项目在编译的阶段 在堆中分配出来的一块存储区域 用于存储显示的量
	
        String s1 = "hello";  
        //在常量池中查找"hello" 没有就新建一个 s1是一个引用 指向常量池中的hello
        String s2 = "hello";
        //此时 s1和s2都指向常量池中的同一个"hello"
        String s4="a"+"b";
        //编译时自动优化成为  s4="ab"
        
    堆
		//JVM在内存中分配出来存放对象等数据类型的区域
		String s3 = new String("hello");
		//创建一个s3对象 存放在 堆 区中 每次调用都新建一个对象
		String s5 = "a";String s6 = "b";
		String s7 = s5 + s6;
			//执行  s5+s6时 JVM会首先在堆区域中创建StringBulider类对象 同时用s5指向的限定字符串对象完成初始化 然后调用 append方法完成对s6的拼接操作 接着用stringBulider类的toString()方法在堆中创建一个新的String对象 将刚刚生成的堆的地址存放在局部变量s7中  s7的值为 "ab"
			//只要其中有一个字符串是利用String类型的变量表示的可能就会和上面进行一样的处理 结果会返回false
			
			
	s1==s2  //判断s1和s2是否指向同一个常量池中的hello (true)
	s1==s3  //判断s1和s3是否指向的同一个地址空间 (false)
	s3=="hello" //s3在堆区域中  而hello在常量池中 (false)
	s3.equals("hello") //equals是判断字符串内容的 (true)
	s4==s7 //s4储存的是常量池中的"ab"  s7是由stringBulider类新建的一个堆地址 (false)
	
	
	限定字符串对象
		//常量池中只有一个 一般不能在常量池中添加一个一模一样的
		//不能同时有两个或者两个以上的对象
			例 String s = "Java";		s = "HTML";
				//第一条语句创建了一个内容为"Java"的String对象 并将其引用赋值给s
			 	//第二条语句创建了一个内容为"HTML"的新String对象 并将其引用赋值给s
	 			//赋值后第一个String对象仍然存在 但是不能再访问它 因为变量s现在指向了新的对象
	 			
	 			
	常规字符串对象
		//可以创建 若干个 数据域中存储字符串 一模一样 的对象
	
```

### 转义字符

| 含义                                              | 转义字符 |
| ------------------------------------------------- | :------: |
| 1~3位八进制数据所表示的字符如\123                 |   \ddd   |
| 4位十六进制数据所表示的字符,如\u0052              |  \uxxxx  |
| 单引号字符 写在""内                               |   \\'    |
| 反斜杠字符 写在""内                               |   \\\    |
| 垂直制表符,将光标移到下一个制表符的位置  写在""内 |    \t    |
| 回车 写在""内                                     |    \r    |
| 换行 写在""内                                     |    \n    |
| 退格  写在""内                                    |    \b    |
| 换页 写在""内                                     |    \f    |
| 空字符(NULL)                                      |    \0    |
| 垂直制表(VT)                                      |    \v    |

```
	
	一点点有趣的东西
	\u2605 五角星  \u2615 咖啡  \u0052 R  \u2333 小三角
	
```

### 字符串类型

```

	String StringBuildr StringBuffer	
	String操作少量数据
	StringBuffer 多线程操作字符串缓冲区下操作大量数据使用(支持同步锁)
	StringBuilder 单线程操作字符串缓冲区下操作大量数据使用
	
```

#### String(线程不安全)

```
	
	是一个对象而不是原始类型
	一旦创建 就不能修改它的值 对于已经存在的String对象的修改都是重新创建一个新的对象 即JVM分配行的堆区域 然后把新的值保存进去 因为String是final类 所以不能被继承
	
	字符串的下标是0~length()-1
	
```

##### 创建String字符串

```
	
	//字符串内容必须包含在一对双引号之内
	//它不属于java的基本类型 是java标准类库中预定义的一个类
	//Java中由双引号包围的都是字符串 不能作为其他数据类型使用 如"1+2"的结果不可能为3
	
	Java中将字符串作为对象管理 可以像创建其他类对象一样来创建字符串对象 创建对象需要用到类String的构造方法 常用构造方法如下
	
	方法一(用一个字符数组A创建String对象)
	 char A[] = {'h','e','l','l','o'};
	 String S = new String(A);
	方法二(提取字符数组A的一部分创建一个字符串对象)
	 char A[] = {'h','e','l','l','o'};
	 String S = new String(A,开始下标,截取字符串的长度);
	 //截取字符串的长度不能超过开始下标之后剩下的元素个数 会报错
	方法三
	 String S = new String("hello");
	
	除了用构造方法还可以用字符串常量的引用给一个字符串变量
	方法四
	String A = "Hello";
	String A;A = "HellO";
	
	方法五
	String A ="H"+"e"+"l"+"l"+"o";
	String A =""+'H'+'e'+'l'+'l'+'o';用字符拼接成字符串是必须要在开头,有一个字符串值,否则字符会被当成Unicode值相加再变成字符串
	
```

##### 连接字符串的两种方式

```
	
	"+"拼接 String B ="1";String C ="1"; String A = B + C;  
	concat方法(值)  String A = B.concat(C);
	
```

##### 比较两字符串是否相等

```
	
	对字符串对象(重点)进行比较不能简单使用"==" 因为比较运算符比较的是两个字符串的地址是否相同
	
	如果地址指向常量池 另一个存放在堆中 使用 == 还是false ==对比的是地址
	
	String A="ABC";String B="abc";
	
	A.equals(B或"abc");(值)(区分大小写)(结果为false)
	A.equalsIgnoreCase(B或"abc");(值)(不区分大小写)(结果为true)
	//暂时用不到 按字典顺序比较两个字符串
	
	equals对比的是 字符串的内容
	
```

##### 判断字符串是否为空

```
	
	String A = " ";
	A.isEmpty();(值)(结果为true)
	
```

##### 字符串的长度

```
	
	String A = "1234";
	A.length();(值)(结果为4)
	//特殊符号和空格也占一个长度
	
```

##### 去除字符串开头和结尾的空格(中间的不去掉)

```
	
	trim();(修饰)(值)
	
```

##### 获取指定索引位置(下标)的字符

```
	
	字符串名.charAt(位置下标);(值)

```

##### 改变字符串的大小写

```
	
	String A ="PPT"; String B = "ppt";
	A.toLowerCase();(值)转为小写
	B.toUpperCase();(值)转为大写
	
	//进行大小写转换,数字或者费字符不受影响
	
```

##### 判断某字符在字符串的位置(字符串查找)

```
	
	//如果没找到返回值是-1
	字符串名.indexOf("某字符");(值)(值为下标)第一次出现的位置
	字符串名.laseIndexOf("某字符");(值)(值为下标)最后出现的位置
	//如果lastIndexOf()方法中的参数是空字符串""(没有空格),返回的结果与调用该字符串length()方法的返回结果相同
	
```

##### 从指定的索引位置开始截取直到该字符串结尾的句子 或 到指定索引位置

```
	
	字符串名.substring(位置下标);(值)截取到结尾
	字符串名.substring(位置下标,位置下标);(值)(前要后不要)截取到位置下标前一个
	
```

##### 查字符串是不是以xx结尾 xx开始

```
	
	字符串名.endwith("xx")	 
	字符串名.startwith("xx")	 
	
```

##### 替换字符串中的内容为新的内容

```
	
	字符串名.replace("要被替换的","新的字符串");(值)
	//如果字符串没有出现在该对象表达式中的字符串序列中,则将原字符串返回
	//如果替换的字符在字符串中出现多次,它将把所有都替换
	//要替换的字符的大小写要与原字符串的大小写保持一致,否则不能成功地替换
	例
	 String A = "java";
     String newA = A.replace("j","J"); //不会成功替换
	
```

##### 判断字符串的开始与结尾

```
		
	字符串名.startsWith("某字符串内容");(值)//判断字符串是否以指定的内容开始
	字符串名.endsWith("某字符串内容");(值)//判断字符串是否以指定的内容结尾
	
```

##### 将其他数值类型转化为String类型

```
	
	String.value of(其他数据类型);(值)
	String A = "ll";int B ="1";
    String C = A + B ;//实质为转换为String对象
    
```

##### 字符串分割

```
	
	字符串名.split("某个字符");以某个字符分割字符串
	//使字符串按指定的分割字符串或字符串对内容进行分割,并将分割后的结果存放在字符串数组中
	例
	 String A = "1,2,3,4";
	 String B[] = A.split(",");//返回值是个String数组
	 
	字符串名.split("某字符",分割次数);//分割次数指的是最后数组有几个值
	例
	 String A = "1,2,3,4";
	 String B[] = A.split(",",2); 
	 
	 在split()方法时没有统一的对字符进行分割的符号，如果想定义多个分割符，可使用符号"|"例如，",|="表示分割符为,和=号
	 
```

##### 将系统当前时间用String类格式化字符串

```
	
	Date date new Date();//获取当前时间
	String S = String.format("%te",date);//用format()方法对date格式化(值)
	
```

##### 将字符串转换成字节数组

```
		
	getBytes();(操作)(返回值是一该字符串分成byte类型字符个数的byte数组)
	//其实转换成了 ascii码
	
```

| 日期转换符 |           说明           |               示例               |
| :--------: | :----------------------: | :------------------------------: |
|    %te     |     一个月中的某一天     |                2                 |
|    %tb     |  指定语言环境的月份简称  |      Feb(英文)、二月(中文)       |
|    %tB     |  指定语言环境的月份全称  |    February(英文)、二月(中文)    |
|    %tA     | 指定语言环境的星期几全称 |    Mondy(英文)、星期一(中文)     |
|    %ta     | 指定语言环境的星期几简称 |     Mon(英文)、星期一(中文)      |
|    %tC     |  包括全部日期和时间信息  | 星期二 三月 25 13:37:22 CST 2008 |
|    %tY     |         4位年份          |               2008               |
|    %tj     | 一年中的第几天(001~366)  |               085                |
|    %tm     |           月份           |                03                |
|    %td     | 一个月中的第几天(01~31)  |                02                |
|    %ty     |         2位年份          |                08                |

| 时间转换符 |                 说明                  |         示例         |
| :--------: | :-----------------------------------: | :------------------: |
|    %tH     |     2位数字的24时制的小时(00~23)      |          14          |
|    %tI     |     2位数字的12时制的小时(01~12)      |          05          |
|    %tk     |      2位数字的24时制的小时(0~23)      |          5           |
|    %tl     |      2位数字的12时制的小时(1~12)      |          10          |
|    %tM     |         2位数字的分钟(00~59)          |          05          |
|    %tS     |         2位数字的秒数(00~69)          |          12          |
|    %tL     |       3位数字的毫秒数(000~999)        |         920          |
|    %tN     | 9位数字的微秒数(000000000~999999999)  |      062000000       |
|    %tp     |     指定语言环境下上午或下午标记      | 下午(中文)、pm(英文) |
|    %tz     | 相对于GMT RFC 82格式的数字时区偏移量  |        +0800         |
|    %tZ     |         时区缩写形式的字符串          |         CST          |
|    %ts     |  1970-01-01 00:00:00至现在经过的秒数  |      1206426646      |
|    %tQ     | 1970-01-01 00:00:00至现在经过的豪秒数 |    1206426737453     |

| 日期和时间转换符 |             说明              |               示例               |
| :--------------: | :---------------------------: | :------------------------------: |
|       %tF        |    "年-月-日"格式(4位年份)    |            2008-03-25            |
|       %tD        |    "月/日/年"格式(2位年份)    |             03/25/08             |
|       %tc        |      全部日期和时间信息       | 星期二 三月 25 15:20:00 CST 2008 |
|       %tr        | "时:分:秒 PM(AM)"格式(12时制) |          03:22:06 下午           |
|       %tT        |    "时:分:秒"格式(24时制)     |             15:23:50             |
|       %tR        |      "时:分"格式(24时制)      |              15:25               |

#### StringBuffer(线程安全 因为这里所以 它比StringBuilder性能差一点)

```
	
	继承抽象类AbstractStringBulider
	在AbstractStringBulider类中
	有两个字段 分别是char[]类型的value和int类型的count StingBuffer本质就是一个字符数组
	其中value用来存储字符  而count表示数组中已有内容的大小(长度)
	StringBuffer的主要方法有、append、insert、delete等 这些操作都是在value上进行的 如果用这些方法 那么value的大小也会随之改变
	
	是一个可变的对象
	当对它进行修改的时候 不会像String一样重新新建对象
	它只能通过构造函数来建立对象 对象被建立之后 在内存中就会分配内存空间 并初始保存一个null
	向StringBuffer赋值 可以通过append方法 他的父类为AbstractStringBulider
	
	StringBuffer类的append方法要比String类的 + 操作符效率要高
	使用String的+操作符给字符串追加字符 字符串对象都需要重新寻找一个更大的内存空间 来容纳更大的字符串 追加大量的字符串很消耗时间
	StringBuffer也就是字符串缓存 可以在预先分配指定长度的内存块建立一个缓存区 所以想给StringBuffer对象追加字符串内容的话 它不会新建堆或者重新寻找更大的堆 可以直接使用StringBuffer的append方法 所以StringBuffer的append方法要比String的 + 操作符执行效率高
	
```

##### StringBuffer创建

```
	
	StringBuffer S = new StringBuffer("Hello");//实例化一个S的StringBufer字符串
	
	//String的增强版 在对字符串频繁修改时 可大大提高程序的可执行效率
	//新创建的StringBuffer对象初始容量是16个字符 可自行指定初始长度
	
```

##### StringBuffer方法(都为对本身操作，且操作都为本身操作)(下标遵循前要后不要原则)

```
	
	String是不可变的 StringBuffer时可变的
	
```

###### StringBuffer追加字符

```
	
	StringBuffer S = new StringBuffer("Hello");//实例化一个S的StringBufer字符串
	
	S.append("world");(本身操作)//在S尾部追加一个字符串，S值为HelloWorld;
	
	[可将此值转为String类型  String A = String.valueOf(S.append("World"));]
	
```

###### StringBuffer本身插入内容

```
	
	A.insert(下标,参数);(本身操作)下标为想要结果的位置下标
	
```

###### StringBuffer删除

```
 	
 	S.delete(开始下标,结束下标);(本身操作) 如果开始和结束下标相等不发生任何更改
 	
```

###### StringBuffer转换成String类型

```
	
	S.toString();//转换成String对象返还回来(StringBuffer、StringBuilder类特有)  所有类都有这个方法因为它是Object父类的特定方法
	
	System.out.println(S);//相当于S.toString();
	
```

###### StringBuffer反转字符

```
	
	S.reverse();(本身操作)
	此时结果为wolleH
	
```

###### StringBuffer替换字符

```
	
	S.replace(开始下标,结束下标,要替换成的字符串);(本身操作)
	
```

###### StringBuffer返回对应下标字符

```
	
	S.charAt(下标);(值)返回此下标对应的字符
	
```

#### StringBuilder(线程不安全)

```
	
	StringBuilder方法和StringBuffer 的使用几乎完全相同参考StringBuffer

```

### 声明数组(一维数组 多维数组)(引用数据类型)

```
	
	数组是一组相同数据类型的元素的集合
	//声明一个数组就是在内存空间划出一串连续的空间
	//数组不是一个类 而是一个特殊的数据类型
	
	//数组长度固定不变 避免数组越界
	//数组中的所有元素必须属于相同的数据类型
	//直接给数组长度的 元素都给开空间
	//边声明边赋值 没有赋值的不给开空间
	
	声明数组的方式
	
	[]放在数组名后和数据类型后面都可以
	
	第一种(先声明后赋值)
	
    一行声明
	数据类型[] 数组名 = new 数据类型[大小];//声明数组并分配空间
	多行声明
	数据类型[] 数组名 ;   //声明数组
	数组名 = new int[大小]  //分配空间
	数组名[] = 要赋的值; //赋值
	
	注:一开始开辟空间的 根据数据类型会有默认值 
		double[] c = new double[5];
        System.out.println(c[1]); //0.0
        //boolean 默认值为false
        //int 默认值为0
        //char 默认值为编码0 注和0是有区别的
	
	第二种(边声明边赋值) 
	//创建数组并赋值必须在一条语句中完成
	数据类型[] 数组名 = new 数据类型[]{值1,值2};
	数据类型[] 数组名 = {值1,值2};
	
-----------------------------------------------------------------------------------------
	
	数组常见错误 ArrgyIndexout of BoudsExeption(数组越界)访问数据中不存在的空间
	
```

### 数组基本操作(下标都为前要后不要原则)

#### 数组输出

```
	
	foreach 循环输出
	
	根据下标 数组名[下标] //从0开始
	
	//将数组中的所有的元素以字符串的形式输出
	System.out.println(Arrays.toString(数组名));
	
```

#### 数组排序(本身改动)

```
	
	Arrays.sort(数组名);
	//将数组按升序排序
	
```

#### 替换数组中的元素(本身改动)(全部)

```
	
	Arrays.fill(数组名,新元素);
	例
	 int[] a = new int[]{1,2,3,4};
	 Arrays.fill(a,0);//将数组a的元素全部替换成0
	
```

#### 替换数组中的某些元素(本身改动)(一段)

```
	
	Arrays.fill(数组名,开始下标,结束下标,新元素);
	例
	 int[] a = new int[]{1,2,3,4,5,6};
	 Arrays.fill(a,0,4,0);//将下标为0到3的元素替换成0
	
```

#### 复制数组(值)

```
	
	Arrays.copyOf(数组名,新数组的长度)
	//如果新数组长度超出原数组长度 新数组将用元素0 将超出的长度补齐
	例
	 int[] a = new int[]{1,2,3,4,5,6};
	 int[] newa = Arrays.copyOf(a,4)
	 newa 数组元素 1,2,3,4
	
```

#### 在一定范围内复制数组(值)

```
	
	Arrays.copyOfRange(数组名,开始下标,结束下标);
	//如果新数组长度超出原数组长度 新数组将用元素0 将超出的长度补齐
	例
	 int[] a = new int[]{1,2,3,4,5,6};
	 int[] newa = Arrays.copyOfRange(a,0,4);
	 newa 数组元素 1,2,3,4 数组长度为4 //左要右不要
	
```

#### 复制数组

```
	
	System.arraycopy(源数组, 源数组中的起始位置, 目标数组, 目标数组起始位置, 复制个数);
	//根据 两个起始位置 可以从一半开始复制
	
	int[] a = new int[]{1,2,3,4,5,6};
    int[] b = new int[a.length];
    System.arraycopy(a,0,b,0, a.length);
    System.out.println(Arrays.toString(b));
	
```

#### 查找数组中的元素(值)

```
	
	Arrays.binarySearch(数组名,要查找的元素);
	//如果数组包有多个带有指定值的元素,无法确定找到的是哪个
	//数组中的元素必须是升序状态 没排序结果可能不是正确的
	//如果有此元素,返回此元素的下标,没有则返回负数
	
```

#### 查找指定范围(数组中)的元素(值)

```
	
	Arrays.binarySearch(数组名,开始下标,结束下标,要查找的元素);
	例
	 int[] a = new int[]{1,2,3,4,5,6};
	 Arrays.binarySearch(a,0,3,2);
	 //如果数组包有多个带有指定值的元素,无法确定找到的是哪个
	 //数组中的元素必须是升序状态 没排序结果可能不是正确的
	 //查找数组中在下标为0到2的位置有没有元素2
	 //如果有此元素 返回此元素的下标 没有则返回负数
	
```

### 二维数组的创建

```
	
	二维数组声明
	数据类型[][] 二维数组名字= new [外围数组长度][内围数组长度];
	数据类型 二维数组名字[][]= new [外围数组长度][内围数组长度];
	
	二维数组赋值
	例
	 数据类型[外围下标][内围下标]=值;
	
	//直接给数组长度的 元素都给开空间
	//边声明边赋值 没有赋值的不给开空间
	
```

### 流程控制

```
	
	条件语句后面的语句序列只有一句需要执行的语句时可以不写{ } 但为了增强程序的可读性最好不要省略
	注意循环语句不要省略括号除了要利用无限循环以外
	在做错误之后重新赋值的时候可以将步长的值变成-1(看情况)
    利用continue可以阻止某个数的输出
	创建标签可以跳出指定循环
	循环条件要记得加步长
	
```

#### if选择语句

```
	条件表达式可以是单纯的true 或者 false 或者一个结果为true false 的式子
	
	if else 语句可以使用三元运算符对语句进行简化
	
	if（a>0){
 	   b=a;
	}
	else{
	    b=-a;
	}
	可以简写成b = a>0? a:-a;  可以用于对比数的大小
	上段代码为求绝对值的语句如果a>0，就把a的值赋给变量b，否则将-a赋值给变量b

-----------------------------------------------------------------------------------------

	if(条件表达式){
        //代码块
	}
	
	
	if(条件表达式){
		//代码块
	}else{
		//代码块
	}
	
	
	if(条件表达式){
        //代码块
	}else if(条件表达式){
        //代码块
	}else if(条件表达式){
        //代码块
	}else if(条件表达式){
        //代码块
	}.........
	else if(条件表达式){
        //代码块
	}else{
        //代码块
	}
	
```

#### switch选择语句

```
	
	表达式可以是个值或者一个变量(jdk6表达式须为值整形或字符型，jdk7可为字符串)
	多个 case 可以合并到一起(利用break) default可以省略但不推荐省略 default也注意写break
	case的 顺序可以被打乱
	注意分支语句的break 结尾  不写结尾将继续执行下面语句
	case的值不可以重复
	
	switch(表达式){
        case 值1 : //表达式为值1走这个
        	//代码块
        	break;
        case 值2 : //表达式为值2走这个
        	//代码块
        	break;
        case 值3 : //表达式为值3走这个
        	//代码块
        	break;
        default : //没有匹配值走这个
        	//代码块
        	break;
	}
	
```

#### while循环结构

```
	
	注意不要错写成这样while(循环条件);程序会认为要执行一条空语句 而进入无限循环 java编译器不会报错
	但可能要费很长时间去调试注意这个问题
	
	while(循环条件){ //先判断后执行
		//循环语句
        步长;//防止死循环
	}
	
	
	
	注意do...while语句的 的结尾要加;号
	
	do{				//先执行后判断
        //循环语句
        步长;//防止死循环
	}while(循环条件);
	
```

#### for循环结构

```
	
	//执行顺序 1 2 3 4 
	//循环变量可以写多个
	
	for(参数初始化1;条件判断2;更新循环变量4){
		//循环操作3
	}
	
```

#### break语句

```
	
	break 结束当前循环 break可以控制一段代码的结束或者一个程序的结束
	
	利用标签可以跳出指定的循环
	标签名：循环体{
        break 标签名；
	}
	
```

#### foreach语句

```
	foreach 语句 foreach语句循环遍历数组
	//int x 引用的变量 arr指定要循环遍历的数组 最后将x输出
	
	int[] arr = new [5];
	for(int x : arr){
		System.out.(x);
	}
	
```

#### continue语句

```
	
	continue 结束当前循环，进入下次循环
	
	利用标签可以入指定的循环
	标签名:循环体{
        continue 标签名;
	}
	
```

## J面向对象

```
	
	面向对象编程和面向过程编程的区别
	
		面向过程的核心是函数 以功能为中心 实现了函数级别的代码重用 没有继承和多态特性
		面向对象的核心是封装了属性和方法的类 以数据为中心 实现了类级别的代码重用 因为具有类所以具有继承和多态特性
	
```

### 包

```
	
	作为Java源代码的第一条语句 用package声明包以分号结尾
	创建包package cn.jbit.classandobject;
	导入包import java.util.*;
	//系统包 java.util  自定义包 cn.jbit.classandobject
	//*指包中的所有类  AccpSchool指包中的AccpSchool类
	
    //包名要求全部小写 一般都是公司的域名倒着写
    //包名之前最好加上唯一的前缀 通常使用组织倒置的网络域名
    //包名以小写字母组成 不能以圆点开头或结尾 .圆点 是文件级层
    
    //允许类组成较小的单元（类似文件夹） 易于找到和使用相应的文件
    //防止命名冲突
	//更好的保护类、属性和方法 
	
```

### J方法

```
	
	//多个方法不能互相嵌套(定义)
	//不能在方法外部直接写逻辑代码
	//方法名的开头字母小写 其他单词首字母大写
	//static修饰的方法 不可以调用非static的属性或方法 非static可以调用static修饰的方法
	
```

#### 权限修饰符

|                       访问包位置                        | 本类 |  同包  |  子类  |  其他  |
| :-----------------------------------------------------: | :--: | :----: | :----: | :----: |
|             private(修饰属性方法)(类可见性)             | 可见 | 不可见 | 不可见 | 不可见 |
|       默认(包存取范围)(只能同包下访问)(包可见性+)       | 可见 |  可见  | 不可见 | 不可见 |
| protected(修饰属性方法)(同一个项目不同包的子类可以访问) | 可见 |  可见  |  可见  | 不可见 |
|          public(修饰类属性方法)(最大访问权限)           | 可见 |  可见  |  可见  |  可见  |

#### 无参无返回值方法

```
	
	权限修饰符 void 方法名(){方法体;}
	
```

#### 有参无返回值方法

```
	
	权限修饰符 void 方法名(数据类型 参数名){方法体;}
	
	//此时定义的参数 成为形式参数
	//可定义多个形式参数
	
```

#### 无参有返回值方法(只能有一个返回值)

```
	权限修饰符 返回值数据类型 方法名(){方法体;return 返回值;}
	
	//返回类型 String int 对象(将多个相关的信息封装成对象,作为参数传递) 数组 等等
	//注意在调用有返回值的方法时 要对返回值进行处理
	
```

#### 有参有返回值方法(只能有一个返回值)

```
	
	权限修饰符 返回值数据类型 方法名(数据类型 参数名){方法体;return 返回值;}
	
	//此时定义的参数 称为形式参数
	//可定义多个形式参数
	
	//返回类型 String int 对象(将多个相关的信息封装成对象,作为参数传递) 数组 等等
	//注意在调用有返回值的方法时 要对返回值进行处理
	
```

#### main方法

```
	
	public static void main(String[] args){
		//方法体
	}
	
	//main 方法必须声明为 public static void
	String[] args 是一个字符串类型的数组 程序开始执行的位置
	
```

#### 方法的调用

```
	
	//static修饰的方法 只能调用static的方法 无static修饰的方法可以调用static方法
	
	//同一个类的方法直接使用方法名()调用
	//不同类的方法需要先创建对象 之后再使用 对象名.方法名()
	
	带参方法
	//调用方法,传递的实际参数要与形参参数列表一一对应(顺序 类型 数量)
	//调用方法时不能指定参数类型
	
```

#### 参数传递类型

```
	
 不叫基本类型叫做 引用 类型

	//值传递的特点：值传递是将一个变量的副本传递到方法中 方法中如何操作都不会改变原本变量的值

	//引用传递的特点(传址):引用传递是将变量的内存地址传递给方法 方法操作变量时会找到保存在该地址的变量 对其进行操作 只会对原变量造成影响
	
	//除了String类和8个包装类虽然是引用类型 但是属于值传递 不会改变此值 String可以说是char[]的包装类 所以它属于值传递
	
```

#### 方法重载(Overload)(多态上 静态加载的多态)

```
	
	方法名+参数列表 叫签名
	
	同一个类 包含了两个或两个以上的方法 方法名相同 参数类列表不同 称该方法 被重载了 这个过程称为方法重载
	
	在同一个类中 方法名相同 参数列表不同（参数类型、顺序、个数）叫做方法重载(Overload) 与方法返回数据类型、访问修饰符无关
	
	方法重载判断依据
	 必须在同一个类中
	 方法名相同
	 参数列表不同
	 返回值无关
	 和抛出的异常类型 权限修饰符无关
	 
	 输出语句就是重载
	
```

#### 方法重写(方法覆盖)(Override)(多态上 动态(运行时)加载的多态)

```
	
	在具有继承关系的子类和父类中 在子类中可以根据需求对从父类继承的方法进行重新编写 称为方法重写(方法的覆盖)
	
	方法重写
	 在具有继承关系的两个类中的子类中
	 方法名相同(重写方法与被重写方法必须具有相同方法名)
	 参数列表必须相同(重写方法与被重写方法必须具有相同的参数列表)
	 返回值相同或是其子类(重写方法返回值类型必须与被重写方法返回值类型相同 或是其子类)
	 权限修饰符不能比父类更严格(重写方法不能缩小被重写方法的访问权限)
	 子类抛出的错误必须和父类异常类型一致或者是父类异常类型的子类
	
```

#### 类的构造方法

```
	
	//就是在创建对象的时候执行一些初始化操作 如给成员属性赋初始值
	
	访问修饰符 构造方法名(与类名相同)(可以指定参数){
        //初始化代码
        //初始化全局属性是要 是要this关键字调用的 不然根据就近原则 name=name 这样使用的是局部变量 正确应为this.name
	}
	
	//注意构造方法时不要忘记初始化
	//构造方法可以重载是特殊的方法重载!!!!!!
	//构造方法是一个与类同名的方法 对象的创建就是通过构造方法完成的 每当实例化一个对象的时候 类都会自动调用构造方法
	//构造方法的特点 方法名与类名相同 包括大小写 无返回值 包括void类型
	//构造方法的作用 完成对象的初始化=创建对象+对象属性赋初始值
	//如果没写带参构造方法 且没写无参构造方法 jvm虚拟机会默认提供一个无参构造方法
	//写了有参构造方法 jvm虚拟机不给你写无参构造方法了 要自己写一个
	
	//构造方法如果用this语句或者super语句调用构造方法 只能是第一条语句
	//在一个构造方法中不允许同时出现使用this和super语句调用构造方法(否则就有两条第一条语句)
	//在实例方法中 this和super方法不要求是第一条语句可以共存
	//在类方法中不允许出现this或super关键字	

	
	//构造方法没有返回值 如果有则不是构造方法 而是和构造方法同名的成员方法
	
```

#### 构造方法的执行过程(多重继承关系初始化顺序)

```
	
	先执行 父类的属性定义 > 父类构造方法 子类属性定义 > 子类构造方法
	
	//如果子类 构造方法 中没有super 显式 调用父类的有参构造方法 也没有通过this显式 调用自身的其他构造方法 则系统会默认调用父类的无参构造方法 -所以不指定super调用父类的无参构造方法 可以不加super();
	//如果 子类构造方法 显式 调用父类的 有参构造方法 则 不执行无参构造方法
	//如果 子类构造方法中 通过this显式 调用自身的其他构造方法 同上两条
	
	//如果 存在多层继承关系 那么会多次向上调用 一直执行到顶层父类Object类 的无参构造方法
	
```

### J抽象原则(了解)

```
	
	属性 和 方法 是为了解决 业务问题
	没有必要不增加 类 属性 方法
	
	抽象 就是简化事务 抓住事物本质的过程
	
	SOLID 原则
		单一职责原则（Single Responsibility Principle  SRP） 一个模块应该只做一件事 并把这件事做好
		开放封闭原则（Open/Closed Principle  OCP） 对扩展开放 对修改封闭当需求改变时 可以扩展模块以满足新的需求 但扩展时 不应该需要修改原模块的实现
		里氏替换原则（Liskov Substitution Principle LSP） 子类必须能够替换成它们的基类
		接口隔离原则（Interface Segregation Principle ISP） 客户端不应该被迫依赖它们不使用的方法
		依赖倒置原则（Dependency Inversion Principle DIP）高层模块不应该依赖于低层模块的实现 两者都应该依赖于抽象 抽象不应该依赖于细节 细节应该依赖于抽象
		迪米特法则（Law of Demeter） 模块不应该了解它所操作的对象的内部情况
		奥卡姆剃刀原则 一个抽象应该足够简单 但又不至于过于简单 这其实就是抽象的真谛
	
```

### J类

```
	
	类是定义了一种抽象的数据类型(抽象了对象共同 属性和方法)  将不同类型的数据集合组成一个整体
	
	程序只能有一个public类 可以有多个其它类
		**//并且 public类名称 必须与java的文件名相同
		
	单单词首字母大写 多个单词首字母大写(驼峰命名)
	
	类 主要由属性(成员变量) 和 行为(成员方法)组成 和代码块统称为类的成员
	
	使用类 的步骤
		使用class 定义类
		使用new关键字 创建对象
		使用.操作符 调用属性和方法
	
```

### J对象(产生 操作 消亡)

#### J创建对象的方法

```
	
	Java 用new操作符 调用构造方法 创建对象 
		*//通过 new 关键字 创建的都是对象
		语法
			Test(类名) A(创建的对象名称) = new(创建对象操作符) Test();
	
	
	*//每个对象都是 相互独立的 在内存占据独立 的内存地址
	*//对象都具有 自己的生命周期 一个对象的生命周期结束 对象就变为垃圾 并被java回收机制处理 不能再使用
	
```

```
	
	使用克隆创建对象clone 需要有一个克隆对象
		被克隆的类必须实现接口 implements Cloneable
		被克隆的类重写clone方法
		初始化被克隆的对象 对象.clone()克隆 因为是Object类型转成对应类型 处理异常
		//被克隆的对象 内容是一样的 但是是两个独立的个体 
		*//注意equals 对于对象时 是比较两个对象的内存地址 类似于== 所以pet1.equals(pet) 等于false
		
		例 Pet被克隆的类 //注意返回是Object
			public class Pet implements Cloneable{
                @Override
                protected Object clone() throws CloneNotSupportedException {
                    return super.clone();
                }
            }
    	需要创建(克隆)对象时
    		Pet pet = new Pet();
            try {
                Pet pet1 = (Pet) pet.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }

```



#### J对象的引用

```
	
	尽管J的一切 都可以看为 对象 但真正的 操作标识符 实质是种引用
	//通常 一个引用 不一定 需要有一个对象 相关联
	
	Book book = new Book();
		引用 只是存放对象的内存地址 不是存放一个对象 严格说引用和对象是不同的 但是可以将这种区别忽略 //可以简单的说 book是Book的一个对象 - 实际上 是book 包含Book对象的引用
	
```

#### J对象的比较

```
	
	"==" 运算符 比较的是两个对象 引用的地址
	"equals" 比较的是两个对象引用 所指的内容是否相等
	
```

#### J对象的销毁

```
	
	当对象的 生命周期 结束时 分配给对象的内存地址 将会被回收 在其他语言中需要手动回收
	对象 引用超过 其作用范围 垃圾回收机制 这个对象将被视为垃圾 将消亡
	将对象赋值为null 将会被回收消亡
	System.gc(); //方法强制启动垃圾 回收器
	
```

#### J类与对象

```
	
	一个类 为他的全部对象给出了一个统一的定义 而他的每一个对象则是符合这种定义的一个实体
	
	类 一类事物的 统称	 对象 从类中抽象出来的个体 由属性 方法组成
	类实质上 是封装对象属性 和 行为的载体 对象则是 类抽象出来的实例
	类 是对象的类型 对象是类的实例
	对象有两个 部分 静态部分(属性) 动态部分(行为)
	抽象的原则 一次只负责一件事
	
```

### J面向对象的三大特性

#### 封装性(private)(面向对象的三大特性)

```
	
	封装 //将类的某些信息隐藏在类内部 不允许外部程序直接访问 而是通过该类型提供的方法来实现对隐藏信息的操作和访问
	
	封装是面向对象编程的核心思想
	
	将对象的属性和行为封装起来 其载体就是类 类隐藏其 实现细节 这就是封装的思想
	
	方便加入控制语句 隐藏类的实现细节 方便修改实现 只能通过规定方法访问数据 类内部数据结构完整 提高维护性

	封装的步骤
	一  修改属性可见性 设为private
	二  创建公有的getter/setter方法 用于属性的读写
	三  根据条件加入控制语句 对属性的合法性进行判断
	
```

#### 继承性(extends)(面向对象的三大特性)

```
	
	//子类 与 父类 是is-a 关系 或是 特殊与一般
个性与共性的关系
	//将子类代码属性和行为 共放入 父类中 提升代码复用
	//缺点 增加了耦合性
	
	类继承语法
		权限修饰符 class A extends B{}
		A B 都为类名 A类继承B类 A类是子类 B类是父类
		
        //权限修饰符 
        	public 整个项目可用
        	无权限符 整个包
        	不可以使用 private 和 protected修饰
        //父类构造方法 private属性和方法 子类继承不了(但是可以调用)   
        //子类单继承父类 父类可多子类 
        //Object 类 是所有JAVA类的祖先 所有的java类都直接或间接的 继承了Object类
        //Object 类会有toString() equals()方法 
	
```

#### 多态性(面向对象的三大特性)

```
	
	继承是多态的基础 
	
	//减少类中代码量 代码可扩展性提高、可维护性提高
	//多态同一个 引用类型 使用不同的实例 而执行不同操作
	//多态是事物 具有多种形态能力的特征 - 同一个实现接口 使用不同的实例 而执行不同操作
	实现多态的核心原理 使用父类的引用 指向子类的对象 也叫子类向上转型 过程自动实现的
	
	实现 多态三要素
		编写具有继承关系的 父类 和 子类
		在子类重写父类 方法
		使用父类的引用执行 子类的对象
	
	实现 多态的两种形式
        使用父类作为方法形参实现多态(常用方式)
	 	使用父类作为方法返回值实现多态(常用方式)

	子类 转为 父类
		向上转型(自动进行类型转换)
		Pet pet = new Dog;
		//向上转型 通过父类引用变量调用的方法是 子类覆盖或继承父类的方法 通过父类 无法调用子类特有方法
		
	父类 转为 子类
		向下转型(强制转换) 结合 instanceof
		Penguin png = (Penguin)pet;
		//可以访问子类特有方法 必须转换为父类 指向的真实子类类型 否则将出现转移异常(ClassCastException)
		
		instanceof 运算符 (必须具有关系 没有就出现编译错误) //该运算符 用于判断一个对象是否属于一个类 或 实现了一个接口
		语法 对象 instanceof 类或接口
		//通常和强制类型转换结合使用

```

### 面向对象如何实现和好处(无用)

```
	
	符合 人类思维 提高 设计 和 开发效率
	
```

```
	
	过程
		显示抽象出类 使用抽象的类实现行为模拟 对类进行优化 封装隐藏类的内部细节 提高安全性
		
		一 发现类 名词  
		二 发现类的属性 名词 
		三 发现类的方法 动词
	
```

### 接口

```

	实现多继承 约束类的行为 接口表示一种能力 接口表示一种规范或约定
	只负责定义实现类 具有的能力 不去关心他如何 实现
	//提现了 约定 和 实现相分离的原则 通过面向接口编程 降低耦合性 提高可扩展性和维护性

```

#### 接口定义

```

	public interface 接口名 extends 父接口,父接口...{
		//常量定义
		//方法定义
	}
	类实现接口的语法
	class 类名 extends 父类名 implements 接口,接口...{
		//类成员
	}
	
	//接口的权限修饰符只能为public
	//接口的命名方式与类相同
	//接口中可以定义常量 不能定义变量
	//接口的属性都会自动用 public static final修饰 即接口中的属性全是全局静态常量(创建时给值)
	//接口所有方法都是抽象方法 接口中的方法都会自动用 public abstract修饰 即接口中只有全局抽象方法
	//和抽象类一样不能实例化  有一些看似是接口实例化的方法不报错是因为 有类隐式的实现了接口
	//接口中不能有构造方法 
	//接口之间可以通过extends实现继承关系 一个接口可以继承多个接口 但接口不能继承类
	//实现类的接口必须实现接口的全部方法 否则必须定义为抽象类
	//一个类只能有一个父类 但可以通过implements实现多个接口  且extends关键字必须位于implements之前
	//良好的接口定义是来自于需求 绝对不是程序员绞尽脑汁想出来的
	//面向接口编程可以实现接口和实现的分离 这样做的最大好处是 能够在客户端位置的情况下修改实现代码
	
```

### abstract抽象类

```
	
	有些类的实例化没有意义 利用abstract限制实例化 除此以外没有任何区别
	例
     public abstract class Pet{
         
     }
    
    abstract也可用于方法-抽象方法
   	 
   	 //abstract可以修饰类和方法 但不能修饰属性和构造方法
     //抽象方法没有方法体
     //抽象方法必须在抽象类里
     //抽象方法必须在子类中全部被实现 除非子类是抽象类
     //抽象类不能被实例化
     //抽象类可以有0~多个抽象方法
     //非抽象子类必须重写父类的所有抽象方法
     //抽象类可以继承实体类
     例
      public sbstract void print();
      
      
      //abstract 不能和 private 同时修饰一个方法 子类无法继承到方法
      //abstract 不能和 static 同时修饰一个方法 无法直接访问一个没有实现的方法
      //abstract 不能和 final 同时修饰一个方法或类 无法重写实现方法
	
```

### 包装类

```
	
	//写传入参数的时候 最好去写包装类 包装类可以接受null值 可以减少报错
	
	Java中共有八个包装类
	//包装类就是将基本类型封装到一个类中 将基本类型包装成一个类类型包装类都在java.lang包中
	//Number类是一个抽象类 包含(Byte Short Integer Long Float Double Boolean类型 和实现它所定义的方法)
	 Character类包装的是字符
	 Boolean类包装布尔类型
	 
	包装类的常用方法
         public Type(type value)
         例 (Type代表标准类类型 , value代表基本类型的值)
          Long longValue() = new Long(21L);
         //一旦创建了某个包装类对象 该对象所代表的值就不能改变了

	 将包装类>基本类型 语法格式如下
         public type typeValue()
         例
          Integer integerId = new Integer(25);//创建一个包装类
          int intId = integerId.intValue();
	
	 将字符串>基本类型 语法格式如下 数据类型格式化 
         public static type parseType(String type)
         例
          int num=Integer.parseInt("36");
          	//将字符串36转换成int类型
          	//格式化字符串必须要 不为空 必须是一串数字 不然会报 数字格式化异常 **建议写的时候就把try catch加上 

          Integer可以实现这样使用是因为它是一个final类可根据类名调取其中方法
     
     
     **//Integer创建对象 开装箱
     	
     	Integer b1 = 10;
        Integer b2 = new Integer(10);
        System.out.println(b1 == b2); //false 两个地址不一样
        
        //Integer b1创建的时候 在装箱 比较的时候会拆箱 是自动拆装箱
        **//装箱没有范围 自动拆箱的范围是 -128 - 127 如果超过这个范围他就不会自动拆箱了
        **//自动拆装箱 只适用于整形 浮点型不行
        //for循环不建议使用Integer 因为会频繁拆装箱 影响效率
        //Integer 使用时建议使用equals 他比较的是内容是否相等(重写了Object的方法)
        
	
```

### this关键字

```
	
	this引用的就是本类的一个对象 代表本类对象的引用
	
	//只要是成员变量就加this  
	//this不能调用类变量和类方法 也不能调用局部变量
	//只能在构造方法中使用this调用自身重载的构造方法 且必须是构造方法中的第一条语句 this();
	//当局部变量和成员变量同名时 为了区分使用this调用同名的变量名使其 成为成员变量
	//this的使用方法 调用属性、调用方法、调用构造方法 this();
	//this可以作为方法的返回值
	例
	 创建一个类 在该类中定义Book类型的方法 通过this关键字进行返回
	 public Book getBook(){
         return this; //返回Book类引用
	 }
	 返回值为Book类 所以方法体中使用return this这种形式将Book类的对象进行返回
	 
```

### super关键字

```
	
	super代表父类对象
	
	//super关键字代表父类对象 可使用super调用父类的属性、普通方法和构造方法 
	super();super(参数); 可以调动父类的构造方法(带参构造方法)//用于确认要使用父类中的哪一个构造方法
	super.属性名; 访问父类属性
	super.方法名();访问父类方法
	
	在子类中调用父类的属性和方法
	//只能出现在子类的方法和构造方法中
	//只在在子类构造方法中调用构造方法,必须是第一句
	//不能访问父类的private成员
	//当父类重新写定义有参的构造方法时,子类必须要重写自己的构造方法
	并在方法前面用super调用父类的构造方法
	
```

### static关键字

```
	
	static修饰的变量称为类变量/常量/方法(静态变量/常量),可以通过类名直接访问
	不使用static修饰的属性和方法通常称为实例变量/实例属性/实例方法
	static 修饰的变量属于这个类所有,即有这个类创建的所有对象共用一个static变量,所有对象对此值的更改都有效
	
	//最先加载
	//不能将方法体内的局部变量声明为static(在方法里不可定义static变量)
	//在静态方法中不可以使用this、super关键字
	//static 的属性方法在调用的时候,直接用 类名.属性名/方法名 就可以了
	//虽然静态成员也可以用 对象.静态成员 进行调用但不建议使用,因为容易混淆静态成员和非静态成员
	//static修饰的方法 不可以调用非static的属性或方法 
	//static可以用来修饰属性、方法和代码块
	//static修饰代码块时会先声明static创建的变量或者常量并加载代码块,再给属性赋值
	//在加载类的过程中,完成静态变量的内存分配,在执行静态块两者是在创建对象之前执行的
	//由static和final修饰的变量成为静态常量
	//static 修饰的属性为全局变量,或者称为类变量,也就是和对象无关
	//static 的属性一旦被改变,对所有这个类的对象都有影响
	//static 修饰的属性/方法 放到访问修饰符的后面,数据类型的前面
	
```

### static修饰语非static修饰的区别

```
	
	static修饰非private修饰 			 	非static和private修饰
	属性 		   类属性、类变量							实例属性、实例变量
	方法  	   类方法							       实例方法
	调用方式	  类名.属性/方法 对象.属性/方法				对象.属性/方法
	归属			类									 单个对象
	
```

### final关键字

```
	
	一、利用final让属性值不再被更改(表示最终版的属性)
	
	final修饰的变量成为常量,其值固定不变
	
	//由static和final修饰的变量成为静态常量 静态常量具有高效性
	
	//常量的组成：final  数据类型  常量名  =  变量值 ;
	//常量的变量名经常全部大写,如果是多个单词也是全部大写,只是用 _ 隔开
	//常量常量值是固定的不可更改
	//定义常量时，必须在一条语句中完成声明和赋值
	//常量一般的定义形式为：static final 类型 常量名 = 常量值；
	
	
	二、利用final让类不被其他类继承(表示最终版的类)
	例
	 public final class Penguin extends Pet{
         
	 }
	 //Penguin不能再被继承
	三、利用final让方法不在被重写(表示最终版的方法)
	 public final void print(){
	
	}
	 //print()不能在子类重写
	四、被final修饰的引用变量,变量的值是固定不变的,而变量所指的对象的属性值是可变的
使用final修饰引用形变量不能再指向另外的对象
	
```

## 异常

```
	
	异常就是在程序的运行过程中所发生的不正常的事件 所需文件找不到 网络连接不通或中断 算术运算出错(如被零除) 数组下标越界 装载了一个不存在的类 对null对象进行操作 类型转换异常等等 
	
	异常处理 程序通过预订的处理办法对异常进行处理 处理完毕程序继续运行
	通过五个关键字实现 try catch finally throw throws
	
	
	try catch块
	把可能出现错误的代码放入try语块 使用catch语句捕获异常
	运行将会出现一下三种情况
	一 所有语句正常执行完毕,不会发生异常 catch不会运行 全部被忽略
	二 遇到异常,异常与catch中声明的类型相匹配try之后的代码不会执行 相应的catch语句被执行 其他的不执行
	三 遇到异常,没有与catch中的类型匹配 程序立刻退出
	
	//catch 可以加入用户自定义处理信息 
	//void printStackTrace() 将输入方法调用出到异常抛出处的方法调用序列
	//String getMessage() 返回异常信息描述字符串 是printStackTrace() 的一部分
	
	Exception 异常层次结构的根类
	ArithmeticException 算数错误情形,如以零做除数
	ArrayIndexOutOfBoundsException 数组下标越界
	NullPointerException 尝试访问null对象成员
	ClassNotFoundException 不能加载所需的类
	InputMismatchException 欲得到的数据类型与实际输入的类型不匹配
	IllegalArgumentException 方法接收到非法参数
	ClassCastException 对象强制类型转换出错
	NumberFormatException 数字格式转换异常,如把"abc"转换成数字
	
	//try catch finally语法
	//其中try块是必须的 catch和finally块可选,但两者必须出现其中之一
	
	try{
        //可能会发生错误的语句  出现异常后将 创建异常对象
	}catch(错误类型 e){//catch语句块之前必须有try语句
        e.printStackTrace();
	}catch(Exception e){
        //可以有多重catch块 但排列顺序必须是从子类到父类 最后一个一般都是Exception类
        //发生异常时系统将从上到下依次匹配,只执行匹配的第一个catch块剩下的都将被忽略
	}
	finally{//finally语句块之前必须有try语句
        //无论是否发生异常,异常是否被捕获 都将在最后执行finally代码块
        //即使try和catch块中存在return语句也会被执行 先执行finall再执行retrun
        //唯一不执行的情况 在try和catch 中执行了System.exit(1),将退出java虚拟机
	}
	
	
	声明异常 throws
	
	如果一个方法体抛出了异常,我们希望调用者即使捕获异常 通过throws声明某个方法可能出现的异常 可声明多个用,号隔开
	例
	 public void show() throws Exception,...{
         //代码块
	 }
	//调用处可以通过try catch捕获异常
	//通过throws继续声明异常,让上一级调用者处理异常 main()方法声明的异常将有Java虚拟机处理
	
	
	自行抛出一个异常 throw
	
	语法 throw new Exception("异常的提示语句");
	catch处理时 需要自己调用printStackTrace()方法输出语句
	
	
	//throw 和 throws 的区别
	一 作用不同 throw 用于在程序中抛出异常对象 throws用于声明该方法中抛出的异常类型
	二 使用位置不同 throw位于方法体内部,作为单独语句使用 throws 必须跟在方法参数类别的后面不能单用
	三 内容不同 throw 抛出一个异常对象 只能是一个  throws 后面可以跟多个异常类型
	
	
	
	//所有异常类型都是 Throwable类的子类 它派生两个子类 Error 和 Exception 
	Error类 表示仅靠程序无法恢复的严重错误  
	Exception类非严重错误
	
	Java异常分类
	
	
	checked异常(非运行时异常),除运行时异常之外的其他继承Exception类而来的异常类,程序必须处理这种异常,否则会报出编译错误
	DataFormatException 数据格式异常
	ExecutionException
	InterruptedException
	IOException(文件输出异常)<<FileNotFoundException 
	PrintException 打印机异常
	SQLException
	
	
	
	RuntimeException运行时异常及其所有子类 (unchecked异常)不要求程序必须对他们进行处理
	 ArithmeticException算术运算异常
	 ClassCastException类型转换异常
	 DateTimeException日期时间异常
	 IllegalArgumentException非法的参数异常
	 IndexOutOfBoundsException数组越界异常
	 NullPointerException空指针异常
	 NoSuchElementException<<<<InputMismatchException输入类型不匹配
	 SecurityException安全性异常
	 SystemException操作系统异常
	
```

## 集合框架

### 集合和数组的区别

```
	
	数组可以 存储 基本数据类型 和 对象 而 集合只能存储 对象 (可以 以包装类 存储基本数据类型)
	数组长度固定不变 不能适应元素 数量动态变换的情况
	定义数组 时必须指定 数组元素类型 集合默认 所有元素 都是Object
	数组可以length获取数组长度(但是不能获取真实存储的数量 只是数组的容量)
	集合可以通过size() 获取集合实际存储的元素个数集合没有length获取长度
	集合有多种 实现方式 对应不同的适应场合 不想数组仅采用分配连续空间
	集合以 接口 和 类 的方式存在 具有封装、继承、多态的特性 通过简单的方法和属性调用即可 实现各种复杂操作 提高了软件的开发效率
	数组 是特殊数据类型 使用Arrays工具类(提供系列静态方法实现对数组搜索、排序、比较) 专门操作数组 
	集合以接口和类的方式 使用Collections工具类 专门操作集合
	*//进行寻找操作的时候效率低下 需要多次比较
	*//没有使用 泛型的集合 取出数据需要 强转
	
```

```
	
	集合框架有三大类接口 List Set Map
	
		接口的具体实现
			Collection接口 储存一组不唯一(允许重复)、无序的对象
			Set接口 继承 Collection接口 存储一组唯一(不允许重复)、无序的对象
			List接口 继承 Collection接口 存储一组不唯一(允许重复) 有序的对象(以元素插入的次序来放置元素 不会重新排列) 
				
```

### List接口

```
	
	List 接口 方法
		
		add()	//向集合中添加对象 还会有返回值 注意其它方法也可能有!!!
		add(指定索引位置,元素)	//在指定索引位置(必须要在0和列表元素之间)添加元素 原索引位置元素向后移动
		size()	//集合中实际对象的个数
		get()	//取出集合中的对象 取出为Object 使用强转
		remove()	//删除指定下标的对象或者指定名字的对象
		contains()	//判断该合集中 是否 包含指定 对象元素
		
	
	ArrayList(在内存中分配连续的空间)(遍历元素和随机访问元素的效率比较高)(可通过普通for和size()方法进行遍历)
		
		//实现接口list 接口必须全部实现
		//遍历速度快 随机访问效率比较高
		//只能存储 引用数据类型 实现了 长度可变的数组
		
		//采用了和数组相同的存储方式 在内存中分配连续的恐惧 添加和删除非末尾元素 会导致后面所有元素的移动 性能低下
		
		
	LinkedList(链表储存方式)(插入、删除元素时效率比较高)(可通过普通for和size()方法进行遍历)
		//实现接口list 接口必须全部实现
		addFirst()在列表的首部添加元素
        addLast()在列表的末尾添加元素
        getFirst()返回列表中的第一个元素
        getLast()返回列表中的最后一个元素
        removeFirst()删除并返回列表中的第一个元素
        removeLast()删除并返回列表的最后一个元素
	
```

### Map接口

```
	
	储存一组成对的键-值的对象 提供key(键)到value(值)的映射(key不要求有序 不允许重复)(value不要求有序 但允许重复)
	
	
	Map 接口 方法
	
		put(key,value)添加一组键-值对(注意键必须是唯一的 如果有重复那最后的键值对会替换的原先的键值对)
        get(键值)根据键返回相应的值 如果不存在返回null
        size()返回元素(键值对)个数
        keySet()返回键的集合
        values()返回值的集合
        containsKey(键值)是否存在键映射的键值对boolean返回类型
        clear()从此映射中移除所有映射关系
	
	
	Hashtable 是线程安全的 不允许null值(key和value) 继承Dictionary类
	HashMap(储存方式是哈希表)(查询指定元素效率高) 重速度轻安全实现线程非安全的 允许null值(key和value) 实现了Map接口 开发最好使用
	
	Iterator 接口 负责定义访问 和 遍历元素的接口(迭代器)(隐藏各种集合 实现类的内部细节)
	通过Collection接口的iterator
		hasNext() //判断是否存在另一个可以访问的元素
		next() //返回要访问的下一个元素
	
```

### 使用Set集合去重

```
	
	List Enployees = new ArrayList<>();
	//add添加数据 
	Set<Enployee> emos2 = new HashSet<>();
	emos2.addALL(Enployees);
	emos2 是去重的 Enployees
	
```

### Iterator集合遍历

```
	 
	 遍历ArrayList和LinkedList
	 Iterator it = dog.iterator();//获取Iterator对象
	 while(it.hasNext()){
         Dog dog = (Dog)it.Next();//取出对应值对象
         dog.print();//输出对应对象的信息
	 }
	 
	 遍历HashMap
	 Map dogMap = new HashMap();//创建hashmap集合
	 //将对象放入dogMap中(略)
	 Set keys = dogMap.keyset();//获取所有key集合
	 Iterator it = keys.iterator();//获取Iterator对象
	 while(it.hasNext()){
         String key = (String)it.next();//取出key
         Dog dog = (Dog)dogMap.get(key);//根据key取出对应的值对象
         dog.print();//输出对应对象的信息
	 }
	 
	增强for循环方法(在JDK1.5加入是for语句的特殊简化版本)(foreach语句)
	语法
	 for(元素类型t 元素变量x:数组或集合对象){
         引用了x的java语句
	 }
	 //其中t类型必须属于数组或集合对象的元素类型
	 
	 遍历HashMap
	 Set keys = dogMap.keyset();//获取所有key集合
	 for(Object key:keys){
         Dog dog = (Dog)dogMap.get(key);//根据key取出对应的值对象
         dog.print();//输出对应对象的信息
	 }//取出值对象
	 遍历ArrayList和LinkedList
	 for(Object A:arrayList){
         Dog dog = (Dog)A;//取出值对象
         System.out.println(dog.print());//输出对应对象的信息
	 }
	
    泛型集合(JDK1.5改写了集合框架中的所有接口和类 增加泛型支持)(使用集合的集合一定要用泛型集合)
    List<Dog> dogs = new ArrayList<Dog>();//标记元素类型后面的<>中可以不填
    Map<String,Dog> dogs = new HashMap<String,Dog>();//标记元素类型后面的<>中可以不填
    注意Map中调用键集Set<String> keys = Map.keySet();//也需要声明类型否则在foreach循环中就不能使用对应类型 (for(String I:keys){}时String I 会报错)
    //使用泛型的框架引用不需要进行强转避免了ClassCaseException异常
    
    //注意使用迭代器时迭代器也需要利用泛型指定类型
    //如果把非指定类型元素放入泛型集合中 则会报编译错误 
    //从泛型集合取出元素时不需要进行强制类型转换
    //集合弥补了数组的缺陷 他比数组更加灵活实用 大大提高了软件的开发效率 可以适应不同场合
    //包含三大块内容 对外的接口 接口的实现 集合运算的算法
    //通常说集合框架包含两大类接口Collection(Set List接口) 和 Map 接口
    
```

## Java多线程

### 继承Thread实现多线程

```
	
	程序(静态的) 进程(正在进行的) //可以同时做两件事
	
	public class AA {
        //主线程
        public static void main(String[] args) {
            //创建
            Newthread newthread = new Newthread();
            newthread.start();
            for (int i = 0; i < 3; i++) {
                System.out.println("主线程"+i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    class Newthread extends Thread{
        //重写run方法
        @Override
        public void run(){
            for (int i = 0; i < 3; i++) {
                System.out.println("线程1"+i);
            }
        }
    }
	
```

### 实现Runnable接口实现多线程

```
	
	public class AA {
        //主线程
        public static void main(String[] args) {
            //创建线程对象
            NewThread2 newThread2 = new NewThread2();
            //创建Thread对象
            Thread thread = new Thread(newThread2);
            thread.start();
        }
    }

    //实现Runnable接口实现多线程
    class NewThread2 implements Runnable{
        //实现run方法
        @Override
        public void run() {
            for (int i = 0; i < 3; i++) {
                System.out.println("线程2");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

### 实现Callable接口实现多线程

```
	
	
	
```

### 线程控制

```
	
	线程运行 的结果是不可预知的 进行控制
	
	线程合并 后台线程 
	
	
	
```

### 线程同步

```
	
	多个线程 对 同一个资源 操作 会出现多个资源抢夺同一个资源 导致程序出错
	
	使用线程同步关键字 synchronized //会影响时间 //又叫线程锁
	//synchronized 可以用在方法上 只有一个线程用完了 下一个线程才可以用 同步方法 同步代码块 
	
	public synchronized void add(){} //同步方法
	
	public void add(){
        synchronized(this){
            //共用代码
        }
    } //同步代码块
	
	加锁方式有两种 
		同步方法 加在方法上
		同步代码块 加在代码块上 需要传递一个对象
	
	//只要保证 并发不出问题 加锁的范围越小越好 最好控制在原子操作 不要加入不想逛
	
	
	
```

### 线程死锁

```
	
	synchronized 解决了 并发对共享资源的修改 操作不安全问题 过多的使用的同步 会导致线程死锁
		
	//锁定了一个对象后 还没被释放之前 又需要锁定另外一个对象 并且这个对象又被另一个对象锁定 这个时候就容易导致死锁
	//尽量不要让 锁定的代码块中再由锁定的代码块
	
```

### 线程通信

```
	
	生产与消费者
	两个线程 一个生产 一个消费 两个线程合作 达到理想状态
	
	
```

## 单元测试

```
	
	把 类中的方法当成一个 单元
	//需要外部jar包
	
	新建类 创建方法 加@Test注解
	之后这个 方法就可以直接执行 测试内容 
	
```



## File I/O

### File

```
	
	文件是指相关记录或放在一起的数据的集合
	
	使用File类操作文件或目录属性
	//java.io包提供了接口和类对文件进行基本操作，读写等等 
	//File对象是java.io包中引用磁盘文件的唯一对象
	File对象即可表示文件,也可表示目录 可以查出与文件相关的信息
	语法和用法如下
	File file = new File(String pathName);//pathName代表文件路径名 注意""
	//注意Windows操作系统路径分割符可以使用正斜杠"/",可以使用反斜杠但必须写成"\\"第一个代表转义符
	//这个 分割符可以用File.separator这个是获取系统分割符 自动分别用/还是\\
	file.exists();(boolean值)//判断文件或目录是否存在
    file.isFile();(boolean值)//判断是否是文件
    file.isDirectory();(boolean值)//判断是否是目录
    file.getPath();(String值)//返回此对象表示文件的相对路径名
    file.getAbsolutePath();(String值)//返回此对象表示文件的绝对路径
    file.getName();(String值)//返回此文件表示的文件或者目录的名称
    file.delete();(boolean值)//删除此对象指定的文件或目录
    file.createNewFile();(boolean值)//创建名称的空文件,不创建文件夹
    file.length();(long值)//返回文件的长度,单位为字节,若文件不存在返回OL
    
```

### Java I/O流

```
	
	读文件 把文件中的数据读取到内存中
	流 指一连串流动的字符,以先进先出的方式发送和接受数据的通道
	
	按流向分 
	
	输入流 OutputStream(字节输入流) 和 Writer(字符输入流) 作为基类(抽象类) 只能读取数据,不能向其中写入数据
	输出流 InputStream(字节输出流) 和 Reader(字符输出流) 作为基类(抽象类) 只能写入数据,不能读取数据
	//基类都定义了一组方法,被访问流的基本特征都是实现基类方法来建立的
	根据流操作的数据单元不同分
	
	字节流 操作最小数据单元8位的字节
	字符流 操作最小数据单元16位的字符
	
	//使用流时一定要注意关闭流
	
```

#### 字节输入流

```
	
	InputStream抽象类
	
	read();(int值)(操作)//读取一个字节数据
	read(byte[] b);(int值)(操作)//将数据读取到字节数组中
	read(byte[] b,int off,int len);(int值)(操作)//从输入流读取最多len长度的字节,保存到字节数组b中,保存的位置从off开始
	close();//关闭输入流
	available();(int值)//返回输入流读取的估计字节数
	//无参的read读取一个八位的字节,把它转换为0~255的整数返回
	//有参的read从输入流中批量读取若干字节,采用此方法可以减少进行物理读文件或键盘的次数,提高输入输出操作效率
	
	 FileInputStream类//常用两种构造方法
	 
	 第一种 先构造个File对象指定file对象
	 File file = new File("文件路径地址");//创建file对象
	 InputStream inputStream = new FileInputStream(file);//创建字节输入流对象 //需要处理异常
	 
	 第二种 直接填写文件路径地址
	 InputStream inputStream = new FileInputStream("文件路径地址");//创建字节输入流对象 //需要处理异常
	
```

#### 字节输出流

```
	
	OutputStream抽象类
	
	write(int c);(操作)//写入一个字节数据
	write(byte[],buf);(操作)//写入数组buf的所有字节
	write(byte[],int off,int len);(操作)//将字节数组中从off位置开始,长度为len的字节数据流输出到输出流中
	close();//关闭输入流
	 
	 FileOutputStream类//常用三种构造方法
	 
	 第一种 先构造个File对象指定file对象
	 File file = new File("文件路径地址");//创建file对象
	 OutputStream outputStream = new FileOutputStream(file);//创建字节输出流对象 //需要处理异常
	 //如果file对象指向的文件路径存在但是代表一个文件目录,将会抛出FileNotFoundException异常
	 
	 第二种 直接填写文件路径地址
	 OutputStream outputStream = new FileOutputStream("文件路径地址");//创建字节输出流对象 //需要处理异常
	 //使用此方法构造如果对应文件不存在,就会自动创建一个空的文件
	 
	 第三种 在第二种构造方式中追加append参数值(true/false)
	 OutputStream outputStream = new FileOutputStream("文件路径地址",append);//创建字节输出流对象 //需要处理异常
	 //append表示是否在文件末尾添加数据,若设置为true,在文件末尾添加数据
	 
	
	 //第一种,第二种构造方法 向文件写数据将覆盖文件中原有内容
	 //字符串提供了getBytes();(返回值可能是字节数组的长度 的一个字节数组)方法将字符串转换成字节数组 可以不指定数组的长度
	
```

#### 字符输入流

```
	
	Reader抽象类
	
	read();(int值)(操作)//读取单个字符
	read(char[] b);(int值)(返回实际读取的字符数)(操作)//从输入流中读取b.length长度的字符,保存到字符数组b中
	read(char[] b,int off,int len);(int值)(操作)//从输入流读取最多len长度的字符,保存到字符数组b中,保存的位置从off开始
	close();//关闭输入流
	
	 FileReader类//常用两种构造方法
	 
	 第一种 先构造个File对象指定file对象
	 File file = new File("文件路径地址");//创建file对象
	 Reader reader = new FileReader(file);//创建字符输入流对象 //需要处理异常
	 
	 第二种 直接填写文件路径地址
	 Reader reader = new FileReader("文件路径地址");//创建字符输入流对象 //需要处理异常
	 
	 BufferedReader类(开发常用) 经常利用Reader(抽象)或子类构造 
     
     BufferedReader br = new BufferedReader(new Reader("文件路径"));//处理异常
     //br就为创建的一个使用默认大小输入缓存区的缓冲字符输入流
     br.readLine();(String值)(一行字符内容)//读取一行数据
     例
      String line = br.readLine();
      while(line!=null){//确保所有行已被输入进来
          System.out.println(line);
          line = br.readLine();
      }
      //先把一批数据读到缓冲区,接下来的操作的都是从缓冲区内获取数据,避免每次都从数据源读取数据进行字符编码转换,提高读取速度
      
      
      //经常通过StringBuffer组合输出字符内容
	
```

#### 字符输出流

```
	Writer抽象类

	write(String str);(操作)//将str字符串所有的字符输出到指定的输出流中
	write(String strint,off,int len);(操作)//将str字符串里从off位置开始长度为len的字符输出到输出流中
	close();//关闭输入流 在关闭之前会默认调用flush();方法
	
	flush();//刷新输出流 清空缓冲区
	
	因为输出流在进行输出时，比如像某个文件中写入内容，其实是先将输出流写入到缓冲区，当缓冲区写满后才将缓冲区的内容输出到文件中。但是当主机完成输出流的输出后，有可能缓冲区这个时候还没有被填满，这样的话，就会一直等待主机发送内容，这时候，就可以使用flush将缓冲区的内容强制输出到文件中，清空缓冲区。 
所以，一般在关闭输出流之前，要先调用flush方法强制缓冲区中的内容输出，并清空缓冲区。
	
	
	 FileWriter类//常用三种构造方法
	 
	 第一种 先构造个File对象指定file对象
	 File file = new File("文件路径地址");//创建file对象
	 Writer writer = new FileWriter(file);//创建字符输出流对象 //需要处理异常
	 //如果file对象指向的文件路径存在但是代表一个文件目录,将会抛出FileNotFoundException异常
	 
	 第二种 直接填写文件路径地址
	 Writer writer = new FileWriter("文件路径地址");//创建字符输出流对象 //需要处理异常
	 //使用此方法构造如果对应文件不存在,就会自动创建一个空的文件
	 
	 第三种 在第二种构造方式中追加append参数值(true/false)
	 Writer writer = new FileWriter("文件路径地址",append);//创建字符输出流对象 //需要处理异常
	 //append表示是否在文件末尾添加数据,若设置为true,在文件末尾添加数据
	 
	 
	 //第一种,第二种构造方法 向文件写数据将覆盖文件中原有内容


	 BufferedWriter类(开发常用) 经常利用Writer(抽象)或子类构造 
     
     BufferedWriter br = new BufferedWriter(new Writer("文件路径"));//处理异常
     br.newLine();(操作)//插入一个换行符(换行)
     //将一批数据写入到缓冲区,缓冲区满的时候,再把缓冲区的数据写到字符输出流中减少每次都执行物理写操作,加快写操作
      
      
     //经常通过StringBuffer组合写入字符内容

	
```

#### 二进制文件的读写

```
	
	二进制常用的类有DataInputStream类和DataOutputStream类
	
	DataInputStream类是FileInputStream的子类是其扩展
	DataOutputStream类是FileOutputStream的子类是其扩展
	
	利用例子
	//创建输入流
	 FileInputStream fis = new FileInputStream("文件路径");//处理异常
     DataInputStream dis = new DataInputStream(fis);//处理异常
	//创建输出流
	 FileOutputStream fos = new FileOutputStream("文件路径");//处理异常
	 DataOutputStream dos = new DataOutputStream(fos);//处理异常
	 //使用
	 int temp;
	 while((temp = dis.read()) != -1){
         dos.write(temp);//temp为指定的字节数据
	 }
	 //读取其他类型例子
	 System.out.println(dis.readByte());
	 System.out.println(dis.readlong());
	 System.out.println(dis.readChar());
	 System.out.println(dis.readUTF());
	 //写入其他类型例子
	 System.out.println(dos.writeByte(1));
	 System.out.println(dos.writeChar('单'));
	 System.out.println(dos.writeUTE("字符串"));
	 //省略关闭流 等复杂结构
	 
	 
	 
	 //两个类搭配使用 可以按照与平台无关的方式从流中读取基本数据类型的数据(int,float,long,double,boolean等)
	 //data输入流可以利用readUTF()方法读取采用utf-8字符编码的字符串
	 //data输出流可以利用writeUTF()方法写入采用utf-8字符编码的字符串
	 
```

#### 区别

```
	字节流和字符流的区别
	
	字符流在操作时使用了缓冲区(内存储存器)(Buffered),而字节流在操作时是直接操作文件的,不会使用到缓冲区
	
	在操作文件流的时候尽量避免使用缓存流，非文本文件也要尽量避免使用字符流 复制出来之后的文件会被减少(原因, newLine()占了多余的两个字节)

```

## 有点东西的例子

```
	
	实现两个整数变量的交换(不需要第三方变量的)
	例
	 第一种
	 int x = 5;
	 int y = 10;
	 x = x ^ y; //5 ^ 10
     y = x ^ y; //5 ^ 10 ^ 10  5
     x = x ^ y; //5 ^ 10 ^ 5   10
	 第二种(有可能会超出int的取值范围)
	 int x = 5;
	 int y = 10;
	 x = x + y; //15
	 y = x - y; //15-10 5
	 x = x - y; //15-5  10
	 
```

## 求一些运算例子

```
	
	long starTime = System.currentTimeMillis();//定义对字符串执行操作的起始时间
	//要进行时间计算操作的时间
	long endTime = System.curretTimeMillis();//定义对字符串执行操作后的时间
	long time = endTime - starTime; //求出进行过程后的时间
	
```

```
	
	求1+1*2+1*2*3......的和
	int A(计和) = 0 ;
	int B(记录每一块运算的值) = 1 ;
	for(int C = 1; i <= 一直乘到多少; i++){
        B=B*C;
        A+=B;
	}
	
```

```
	
	分解得到一个数的个、十、百、千数
    int gewei = 1234%10; 		 geiwei=4
    int shiwei = 1234/10%10;     shiwei=3
    int baiwei = 1234/100%10;  	 baiwei=2
    int qianwei = 1234/1000;	 qianwei=1
	
```

```
	
	数组找最大值,最小值方法
	
	方法一
	int max = a[0]; //将数组中一个元素赋值给max
	//循环对比数组中是否有其他元素比max大 如果有将此元素的值赋值给max
	for(int i = 0 ;i < a.length;i++){
        if(a[i]>max){
            max=a[i];
        }
	}
	
	方法二
	通过数组排序 Arrays.sort(数组名);//将数组按升序排序
	
```

```
	
	升序和倒序输出数组元素
	
	方法一
	升序
	int[] a = new int[]{1,2,3,4};
	for(int i = 0;i < a.length;i++){
        System.out.printl(a[i]);
	}
	倒序
	int[] a = new int[]{1,2,3,4};
	for(int i=a.length-1;i > -1;i--){
        System.out.printl(a[i]);
	}
	
```

```
	
	向数组中插入一个元素 插入算法
	
	int a[] = int[6];
	int index = 
	
	
```

```
	
	遍历二维数组
	
	方法一
	int[][] A = new int[][]{{1,2},{3,4},{5,6}};
	for(int i = 0;i < A.length;i++){
        for(int j = 0;j < A[i].length;j++){ //循环遍历
            System.out.print(A[i][j]);
        }
        System.out.print();//输出空格
	}
	
	方法二
	int[][] A = new int[][]{{1,2},{3,4},{5,6}};
	System.out.println("数组中的元素是") //提示信息
	int i = 0 ; //外层循环计数器变量
	for(int x[] : A){ //外层循环遍历为一维数组
        i++; //外层循环计数器递增
        int j = 0; //内层循环计数器
        for(int e : x){ //循环遍历每一个数组元素
            j++;	//内层循环器递增
            if(i == A.length && j == x.length){ //判断变量是二维数组中的最后一个元素
                System.out.print(e);  //输出二维数组的最后一个元素
            }else{
                //如果不是二维数组中的最后一个元素
                System.out.print(e+"、"); //输出信息
            }
        }
	}
	
```

```
	
	打印矩形
	
	方法一
	for(int i = 1;i < 5;i++){ //控制几行
        for(int j = 1;j < 9;j++){ //控制一行多少个
            System.out.print("*");
        }
        System.out.print("\n");//换行
	}
	
	
```

```
	
	打印三角形
	
	方法一
	for (int i = 1; i < 9; i++) { //i控制行数
         for (int j = 0; j < i; j++) { //j<i 控制三角形是第几个应该输出第几个
         System.out.print("*");
         }
         System.out.println("\n");
    }
	
```

```
	
	打印九九乘法表
	
	方法一
	for (int i = 1; i <= 9; i++) { //i从1开始 i<=9乘法表有九层
         for (int j = 1; j <= i; j++) { //j从1开始 j<=i 一直乘到相同的数
             System.out.print(i+"*"+j+"="+i*j+"\t"); //输出式子
         }
         System.out.println("\n");
    }
	
```

## 注意  和  一些特殊写法

```
	
	byte A = 3; byte B = 4; byte C = A+B;  会报错 但 byte A = 3 + 4;不会报错
	//byte在与byte(或short,char)进行运算的时候会提升成int类型
	//JAVA编译器有常量优化机制   常量直接判断是否在变量类型之间    而 变量是变化的无法判断里面的值相加可能会超出 byte的取值范围
	
	//注意分清 对比时两个对象的类型 string .equals                 整形用 == 
	
	//在字符串操作中有些操作  注意加双引号   注意操作的类型
	
	//字符串的操作下标服从前要后不要原则
	
	//随机数 random.nextInt(6);//生成0~5的随机数
	
	//比较运算符比较的是两个字符串的地址是否相同，即使两个字符串的内容相同，两个对象的内存地址也是不同的，使用比较运算符仍然会返回false 解释片段 待重写  ,注意做字符串的对比 并记录结果 等于号对比的是两个变量的位置 而 equals对比的是两个变量的内容
	
	//判断字符串为空值为""注意isEmpty需要字符串有值，如果只声明一个数组(只给长度)或字符串(声明时给值null)它的每个元素(一个元素)都为null 没有(值)所以isEmpty( )方法会报错【只能用==null】进行对比
	
	//在lastIndexOf()方法中的参数是空字符串""（注意没有空格），则返回的结果与调用该字符串length（）的返回结果相同
	
	//Java中 一句相连的字符串不能分开在两行中写字符串的连接，如果一个字符串太长，为了便于阅读，可以将这个字符串分在两行上书写，此时就可以使用“+”将两个字符串串联起来之后在加号处换行
	
	//打完程序之后要记得测试运行 debug  测试不可少
	
	//注意题目中的=号和==号
	
	//  /正斜杠 \反斜杠 {}花括号  ()括号  【】中括号
	
```

# 备用

```
	
    java1.8 jvm会将内存划分区域 分为堆\栈\方法区 每个区域存储不同的数据
    
    左栈右堆
 *  堆:
 *      1.8以后所有静态的 都存储在堆中的静态方法区
 *      对象的生命周期:
 *          当一个对象没有被任何的应用指向的时候 该对象被视为可回收范围(在该对象的成员变量空间一并被收回)
 *
 *
 *  栈:
 *      jvm会在内存中开辟一个空间叫栈
 *      栈中只存储局部变量(在定义方时,方法中的变量都成为局部变量)
 *      何时存在 开始执行方法 将局部变量在栈中开辟空间
 *      何时释放内存 方法结束后 该方法栈中的所有变量都会被释放
    
    
    成员变量
 *      定义在类中
 *      有默认值 可以不显式初始值；
 *      所在的类被实例化后 存储在堆中 对象被回收 成员变量失效
 *   局部变量
 *      定义在方法中
 *      没有默认值 需要自行设置初始值
 *      方法被调用时 存在栈中 方法调用结束 从栈中清除
 *
 *   方法区
 *      方法区存储类信息 java程序运行时 类加载器载入字节码信息 经过解析后将其转入方法区
 *      方法只有一份 当类的信息被加载到方法区是 除类的信息外 同时类内的方法方法定义也被加载到方法区
    
    
    
    
    
    
    
    
    
    
    
    
	
```





```
	
	//取消 度娘栏 简化内容 笔记只 记录 重要的纲要结构 自己读懂就好 但是要有良好的纲要结构 保持高度可读性
	/总结的图片 最后是学完之后或者 有大部分内容了之后 凭借感觉选的图
	
	"+" 代表public 
	"-" 代表private 
	
```

