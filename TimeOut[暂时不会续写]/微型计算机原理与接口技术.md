```
	2022年3月22日22:20:17创建
	2022年6月12日20:12:36第一次完结
	2022年6月13日09:19:05 错字 错逻辑整理
```

# 目录

[TOC]

# 微型计算机与接口技术

## 简写表

```
	
	为了方便 后缀表示 数的进制
	
	二进制 B
	八进制 Q或o
	十进制 后缀D或省略
	十六进制 后缀为H
	
```

## 关于一些人物和计算机相互关系 和一些事(心存敬畏)

```
	
	冯诺依曼 是 阿兰图灵 的 老师
	冯诺依曼 是 ENIAC 的技术顾问 不是 设计人员 
		它给埃尼阿克 提出了两个不足
			计算机应该使用2进制 不是10进制
			优化编程序
				//当时的电脑就是 插不同的插线孔改变电路
				//冯诺依曼提出 应该由电脑自己调整电路 通过01代码(01代码存储在计算机中) 最后提出了冯诺依曼体系
	冯诺依曼 死 硬盘也还没出来 但是硬盘是个伟大的发明
	
```

## 计算机基本概念

### 什么可以叫做计算机

```
	
	可以用来代替人脑计算的设备
	
	//算盘 算 计算机 计算机博物馆有
	
```

### 计算机就是进行数据处理的

```
		
	存储 运算 传输
	
```

### 关于第一台电子计算机

```
	
	埃尼阿克(ENIAC) 10进制计算机 
		//1946年
	
```

### 计算机为什么用二进制

```
	
	计算机 只能学会二进制
	
	//其它的进制 也可以 但是 没有二进制稳定 //例如电压 但是极易受到干扰
	//16进制 纯属是为了方便 人记忆二进制
	
```

### 计算机的位数

```
	
	几位计算机指 
		例如 8位计算机 
			//一下进行8位二进制 存储/运算/传输 位干的活
			//每运算一次最多加8位
			//可以处理高位的 处理64位的数据要进行 8次操作 只是慢
			//具备多少运算能力是看cpu的位数的
			
```

### 计算机的划分

```
	
	计算机 根据运算能力 来划分  注意 不一定体积很大 体积不能是计算机划分的主要区别
		//运算能力 指 计算机的运算速度 计算机底层只能算加法 所以计算机只是个加法器
		//每秒钟计算多少次加法
		//自我理解 具备多少运算能力是看 cpu的位数的
		
	
	分为 (主要使用场合)
		巨型计算机 (航空航天气象)
		大型计算机 (通讯银行)
		中小型计算机 (基本没有场合使用)
		微型计算机 (家用电脑)
	
```

### 计算机的相同点

```
	
	组成结构 是一样的 
	//现在的计算机只有一种结构 冯诺依曼体系结构
	所以计算机也叫 冯诺依曼计算机
	
```

### *冯诺依曼体系结构

```
	
	规定计算机由两部分组成 分为
		硬件组成部分
			运算器 控制器 存储器 输入设备 输出设备
            	//输入设备和输出设备 包含(I/O接口和外设)
		
		软件的执行方法
			二进制的程序存储执行方式 程序存储在内存
	
```

### 存储器

```
	
	也叫内存 //数据可以被运算器(cpu)直接访问 
	//注 硬盘 算外储存器 硬盘算I/O设备 //运行时是 硬盘载入内存 CPU处理内存
	//程序在外存 是不能运行的 必须要 载入内存
	
```

#### 内存组成(可能不正确)

```
	
	内存条 
	高速缓存(cache)(集成到cpu里面的) 读取速度高 存储空间较小 位于 主存和CPU中间
	bios(基本输入输入系统)(是种程序 存在内存中有一个bios芯片 8条蹆 内存芯片) 
	
```

#### 存储器大类

```
	
	内部存储器(内存 或 主存) CPU可直接访问 
	外部存储器(外存) 使用时必须先调入内存 
	
```

#### 内部存储器分类

```
	
	ROM(只读内存) //特殊写法可以写入
    RAM(随机储存器)
	
	//本质区别 是 易失性(RAM断电后信息丢失 ROM不会自动消失)
	//Bios在ROM中存放 其他应用程序都在RAM
	//运行时就是 cpu处理内存当中的东西
	
```

#### 存储器的结构

```
	
	分为两种
		
		哈佛结构(大多数手机)
		冯诺依曼结构(大多数通用电脑)
	
	//注意 计算机只有 冯诺依曼体系结构 一种  而是存储器 有两种结构
		
```

#### 存储器其中数据单位等

```
	
	4GB 
		//4G 只是个数 是数字的缩减表达法
		//B 是单位 字节 大B和b有区别 //！！！内存的单位是字节
			1G=1024M 1M=1024k 1k=1024B 1B=8b(bit)
				//一个字节等于8个二进制位
                //注意单位场合
			//最小的存储单元是位(bit)
			//最小的存储单位是字节(B)
		//4GB内存等于32Gb的内存 
		
```

### I/O接口

```
	
	输入/输出接口电路用于 CPU(或存储器) 之间的信息交换
	现在的计算机系统中 这些芯片的功能被 集成 在大规模集成电路芯片中
	
```

## 计算机发展史

```
	
	电子管计算机
    晶体管计算机
    集成电路(集成电路芯片)计算机
    大规模集成电路计算机
	
```

## 关于程序

```
	
	程序 是 数据加方法的集合 是指令和数据
	程序最终 是由 运算器(cpu) 和 控制器(cpu) 配合完成的
	//电脑运行程序时  程序是在RAM取的 数据也是在RAM取得
	程序和数据 在内存中都是 以二进制 存放的
    
```

## 关于手机

```
	
	手机属于 嵌入式设备(和 智能设备冰箱什么一类)	
	
```

### 手机内存

```
	
	ROM机身内存(内存可直接运行程序)
    RAM运行内存(数据加载在运行内存中)
	
	//手机没有硬盘的概念
	//手机cpu运行程序的时候 会从ROM拿指令 会从RAM拿数据 将这些都放到cpu中处理
	
	手机的大部分 存储器结构 是哈佛结构
	
```



## 微型计算机基本概念

### 什么是微型计算机

```
	
	采用了 微处理器 存储器 输入/输出接口电路 和 系统总线组成
	
```

### 微型计算机特点

```
	
	体积小 功耗低 重量轻 可靠性高 结构配置灵活 价格低廉 
	
```

### 微型计算机分类

```
	
	分两类
		通用电脑
		嵌入式电脑
	
```

### 微处理器发展历史

```
	
	//位数也可以称之为cpu的架构
	
	Intel 英特尔 1967成立 全球最大的微处理器 制造商
		//霍尔将 运算器和控制器 集成到一体 一个芯片中 
	
	4004 
		//1971
		//微处理器诞生 4位
		//第一个单芯片cpu 微处理器 集成在集成芯片的cpu 
	
	8008 
		//8位
	
	8086
		//1978
		//16位
		//体积变小>功效低>发热低>稳定更稳
	
        IBM(1981 采用16微处理器 做出了计算机 IBMXT机 第一台微型计算机)
            //硬件采用Intel
            //软件采用微软(全球最大操作系统的供应商)Dos系统(微软买的)
         
	80386
		//32位
	
	
	//等待补充
	
```



### 微型计算机系统

```
	
	//注意 操作系统 和 系统 的区别
	
	分为两部分 因为是冯诺依曼结构
		硬件
			微处理器 
				//其中的数据只和 存储器 和 I/O接口来往
			存储器
			I/O接口(不包含外设的)
				//高速CPU和慢速的I/O设备 速度不匹配 所以需要I/O接口(也叫接口芯片)
				//有一种外围设备(外设)就有一种接口
		软件
			系统软件
			应用软件
			开发调试类软件(汇编语言 或者 debug)
	
	
```

### 微型计算机的三种工作

```
	
	存数据 CPU到内存 
	读取数据 (指令) 内存到CPU
	读取数据 (数据)	内存到CPU
	
	取指 取数 存数
	
	
	工作流程
	
		CPU -交互- 内存(取指 取数 存数) -交互- I/O接口(取数 存数)
			//CPU只能和内存直接交互
	
```

### 总线 

```
	
	计算机系统中 各个部件间 传递信息的 公共通路 叫总线 微型计算机是以 总线结构 来连接各个功能部件的
	只要 符合 总线 标准 部件 就可以 加入到系统中
	
```

### CPU如何分清二进制数是数据还是指令

```
	
	通过分线 //以同位数 进行二进制传输
	
	线的分类
			内部总线 //CPU内的线路
			外部总线 //其它在cpu外的线路
				系统总线 //用来连接 构成微处理机的各个插件版
                    元件级总线 //连接 CPU 至 内存 至 I/O接口之间的线路
                    AB(addressBus)(地址总线) //传地址
                    DB(dataBus)(数据总线)
                    CB(controlBus)(控制总线)
				外围总线
					PCI
					USB
		
		分不同的总线
			
```

### 内存示意图

```
	
	上不封顶 下部封底 开口处封顶
	
	一个格 是一个 字节(能存8个二进制位)
		//一个字节 最多存0~255个数 带符号的 127~-128(不等分是因为 对0进行了补码)
		
	
```

### 数据类型

```
	
	计算机 存储 的数据类型 有 字节 字 双字等
	一个字节为 8位 二进制数 //分为有符号和无符号数
	一个字 为 16位 二进制数 //由两个字节组成
	双字数据 有四个字节 为32位 位 二进制数
	
```



## 以8086为基础学习



### 内存与偏移地址

```
	
	内存要多大 需要看cpu的位数 
	//32位的cpu 最大装4GB内存(2的32次方 之后换成4G B) cpu想工作要操作系统
	
	8086是16位的
		//理论上只能使用2的16次方 64k
		//但是上了1024k(20位的内存地址) 地址 通过分段 进行正常使用
		//每段叫做 段地址
		//每段的 某一个 叫做 偏移地址 
		//段可以不均匀 最多可以分65536个单元 因为16位最多识别 2^16的 地址
		*/段地址 偏移地址不唯一 只有物理地址的唯一的
		
```

### 物理地址和计算

#### 两种表示方法

```
	
	一 直接写出来的20位物理地址
	
	
	二 段地址:偏移地址 //也叫逻辑地址
	
	
	*/ 物理地址 = 段地址 * 10H(末位+0) + 偏移地址
		例 物理地址1234H:0005H
			12340H + 0005H = 12345H
		*/ 物理地址1230H:0045H
		    12300H + 0045H = 12345H
		    //说明了 段地址和偏移地址 都不是唯一的 //他们不相同但是指着相同的物理地址
	
	*/因为是4位二进制数 四个4bit代表 一个数 简写成下面的方式
	//12345H 是20位的地址  物理地址  (0001 0010 0011 0100 0101)B
	//1234H 是16位的地址  偏移地址	(0001 0010 0011 0100)B
	
```

### CPU(微处理器)

#### 学习单

```
	
	编程结构
	引脚定义
	系统组成
	编程方法
	
	CPU 是一个可编程芯片
	芯片 分为 
		不可编程芯片 只需要物理部件 74LS138 数模转换芯片  
		可编程芯片  需要物理部件和程序 CPU I/O接口芯片
	
```

#### 8086CPU内部编程结构	

![](..\Images\微型计算机原理与接口技术\8086cpu结构.jpg)

```
	
	主要组成 
		BIU 总线接口部件
			//物理地址形成 取指 指令排队 读/写操作数 总线控制
			//负责cpu内部总线 与 外部系统总线的交互 CPU只能通过BIU与外界进行交互所以内存 接口的数据都要通过BIU
			

			
		EU 指令执行单元
			//EU从BIU的指令队列 中取出指令 执行指令 不访问存储器或I/O端口 
			//需要数据输入输出也是在BIU中形成物理地址 访问存储器或I/O端口 取得操作数送到EU 让BIU做
			
		//BIU和EU的操作是并行的
		//黑色的线 是内部总线
		
		
```

##### BIU组成

```
	
		16位段地址寄存器 //4个寄存器
			CS 代码段寄存器
			DS 数据段寄存器
			ES 附加段寄存器
			SS 堆栈段寄存器
		16位指令指针寄存器
			IP寄存器  下一条 要执行指令 的偏移地址 BIU自动修改
    	20位物理地址加法器 (求和符号部件)
    		讲16位段地址和IP指令指针偏移地址 进行加法操作 获取20位物理地址 
    			//将16位逻辑地址 变换成 存储器 读/写 所需要的20位物理地址
    			段地址*10H + 偏移地址  
    				//*10H 注意因为段地址和偏移地址可能都是16位的缩写 所以如果不是简写的话其实是加了4个0
    	6字节指令队列缓冲器
    		//只能填充指令 不能填数据 
    			//数据BIU取 了之后放到内部寄存器中 是CPU自己访问的(不用管) 后面是存到 EU的通用寄存器中使用
    		//预放6字节的指令代码
    		//先进先出队列寄存器
    		//一般情况 指令队列中填满指令 EU可以从指令队列取出指令 EU取走一字节的指令代码后 自动调整指令队列输出端指针 当指令队列有2个或2个以上的字节空余时 BIU自动 将指令取到指令队列中 
    		//程序不一定是顺序执行的 循环结构和跳转语句 都会导致指令队列全部情况 所以写代码要少写
    		//8086cpu 只有单字节 双字节 三字节指令
    		//当指令队列已满 并且执行部件EU未向BIU申请 读/写 存储器操作数 则BIU不执行 任何总线周期 处于空闲状态 
    		
    		
    	总线控制逻辑(电路)
    		//发出总线控制信号
    		//不是重点 发出总线控制信号
		
	
```

##### EU的组成

```
	
	算数逻辑部件ALU 
		//操作数可以从 存储器 寄存器组 取 一般情况下 指令顺序执行 EU从BIU指令队列取 不是访问 存储器取 所以可以并行操作 但是 有时候遇到转移 调用 返回指令 要将指令队列中的内容作废 等到BIU重新填充指令队列时 EU才能继续运行 此时并行会受到影响 EU与BIU 相互配合又相对独立
        //16位暂存器 暂存 参加运算的操作数 运算结果由内部总线送到EU的寄存器组送到BIU的内部寄存器 由BIU写入存储器或I/O端口
	EU控制器
		//负责从队列中取指 指令译码 以及发送控制命令 
	16位标志寄存器PSW
		//保存运算后结果的特征状态
		
		8086标志寄存器简图 //16位 16个格子 从左往右先D15 到D0
		15 14 13 12 OF DF IF TF SF ZF 5 AF 3 PF 1 CF
			CF 进位标志位
			PF 奇偶校验位
			AF 半进借位标志
			ZF 零标志 1结果为0 0结果不为0 //有没有0
			SF 符号标志 -1 为1 有符号 //有没有符号
			IF 中断允许
			DF 方向标志
			OF 溢出标志
		//有3个 控制位 6个状态位 7个没有用
	
	通用寄存器	
		一个格子 可以存一个字
		4个16位的通用寄存器 //可以划分成高低八位用
            AX	AH AL
            BX	BH BL
            CX  CH CL
            DX  DH DL
            //AX用过了就不能 在用AH AL了 会被覆盖
          
        4个专用寄存器
        	SP 堆栈指针寄存器
        	BP 基址指针寄存器
        	DI 目的变址寄存器
        	SI 源变址寄存器
       		//专用寄存器 不一定是专用的 特殊场合下是专用的
		
	运算寄存器 
		//不用管
		
```

#### 运行一个程序

```
	
	
	1 2 3  程序运行
		//任何一个程序 都是由 数据 和 指令组成的 (数据和指令 是分段的)
	
	程序都在外存 不能被直接运行 必须要载入内存  
		1 2 3 程序被分别分段 载入到内存中  
			例如 1号 代码段 数据段 附加段 堆栈段
			//加载 一个程序 可以分 1~4个段 任何一个程序不能没有代码段(指令) 任何程序 加载到 内存 中最多划分 4个段 //段的数量是由 人在代码中定义好的
			//数据可能被存放在 数据段 附加段 堆栈段 中 但是偏移地址是 由代码指定的
			//代码段地址被存放在CS寄存器中 和 IP指令指针寄存器获得物理地址  IP永远指向下一条指令偏移地址 并且自动指针下移
			//这些段地址都会被放在 CPU中的 4个对应的1 16位寄存器中 
			//BIU里面的段寄存器里(CS DS SS ES)  //存放当前程序 只能放一个程序 的段地址 所以计算机在某个时刻只能有一个当前程序 
			
	//EU 从BIU的指令队列 输出端驱动指令译码 运行 若需要访问内存或者I/O接口则 EU将地址的偏移地址 通过内部总线送给BIU BIU在加法器中形成20位物理地址 申请访问存储器或I/O端口 之后将操作数送给EU
	//指令队列已满 执行部件 不适用总线 总线接口部件进入空闲状态
	
	
```



#### 运作

```
	
	IP(指令指针 寄存器) 指向 要执行的 下一条指令的偏移地址
    	顺序执行指令 每取一次增加 相应计数
    段寄存器 给出存储单元的段地址
   		偏移地址与段地址 组成20位物理地址 在存储器中寻址
   	标志寄存器PSW(或flag) 存放算术 与 逻辑运算结果的状态(溢出 符号 进位 等)
	
	控制逻辑部件 负责整机控制 包括(取指 对指令译码分析 发出控制信号 时序 让CPU内部 外部协调工作)
	
	//微处理器 不能独自 工作 执行程序 必须加上 存储器 输入/输出 接口 构成一台微型计算机方能工作
	
	
```

#### CPU周期

```
	
	单位就是  秒 微秒 毫秒 
	总线周期 BIU 干一次活的时间 就叫一个总线周期
		//BIU 就三种活 取指 取数 存数
		//一个总线周期最少是4个时钟周期
			//通常叫做T1 T2 T3 T4个时钟周期 
			//CPU干活是按照规律的
			//例 取值 
				T1	发出地址
				T2  撤销地址,为数据传输做准备
				//因为I/O接口上可能数据没有准备好 所以要等待 Tw状态 等待要根据实际的时间来 所以最少四个时钟周期

				T3  数据传输
				T4  结束状态 结束态
				
		
	时钟周期  
		//时钟周期(晶振) 5MHZ 10MHZ
		//CPU主频越高时钟周期越短 CPU主频越高电脑运行越快
	
```

#### CPU I/O 存储器 数据传输

```
	
	cpu 的小房间叫做寄存器 根据名字访问 寄存器名
	存储器存放数据的小空间叫做 存储单元bit 根据存储单元地址访问的
	i/o端口 也有放数的小空间 叫做端口 根据端口地址访问的
	
```

#### 关于CPU架构

```
	
	主流 
		x86架构
			//主要占有电脑架构
			//发展最为成熟的 有能力生产的只有 Intel AMD
			
		ARM(必须大写)架构
			//主要占有手机架构
	
```

### 8086汇编

```
	
	汇编语言中 使用伪指令 定义 
		字节(Byte) DB
		字(Word) DW
		双字(Double word) DD 
		四字 DQ
	
	低级语言 //都是可以直接操作 高级不能直接操作 //高级语言关注算法
		机器语言
		汇编语言
		
	学习汇编 只是为了了解计算机运行机制
	每一种cpu有着不同的编码方式 ARM Intel 都不一样
	指令是向下兼容的 8086的指令 在 i7上运行 
	
```

```
			
	编辑源程序 .ASM 经过汇编》 目标文件.OBJ(二进制 不能被直接执行) 经过连接》.EXE (//可以被cpu执行的二进制代码)
	//连接是 连接计算机中的库 让计算机运行
	//OBJ文件最小 
	
	32位系统可以运行DOS 但是8086的这些是16位的 64位系统运行不了 使用DOS模拟器
	
	//都在DOS下完成
        编辑源程序 在DOS下完成 EDIT //记事本也可以
        汇编 MASM.exe
        链接 Link.exe
        DOS 直接执行
        DOS 调试
	
```

#### 命令 操作

```
	
	dir 查看指令
	cls 清屏
	del 路径文件名带后缀 删除文件
	type 文件名 看文件内容
	
	//上为dos命令
	
	挂载 //将外部命令挂载到c盘
		mount c (MASM.exe,Link.exe,debug.exe所在目录)
			//挂在完之后C:切到C盘符之后dir就有命令了
			//每次开启DOS都要重新挂载 所以进行以下
				//打开DOSBox 0.74 Options.bat 更改conf
				//最后输入 挂载和换盘符也可以加入清屏 每个一行回车隔开
		
	EDIT编辑
		edit a.asm 编辑a.asm文件没有自动创建 但是需要保存 -dos命令
		edit进
	
	//下为源程序 汇编指令
	
	//定义数据段 程序段 附加段 堆栈段
		//定义一个代码段地址 定义一个段地址 assume指定段类型 代码段自动传递到CS(段传送)
        abc segment
        	assume cs:abc //要放在段定义 第一句
            start:
            mov ax,5
            
            mov ah,4ch
			int 21h
        abc ends
        	end start
        //abc是段名字 段名字不能超过8个字符 超过只要前八
        //segment定义开始 ends定义结束
        //assume xx:段名称 表示它是什么段 cs是代码段
        //start: 开始标志 start可以自定义
        //end start 结束开始标志
        //mov 目的操作数 源操作数  将源操作数 移动(传送)到 目的操作数中
        //8086 根据操作数 将指令分为 单操作数指令 双操作数指令 无操作数指令
        //mov ah,4ch 和 int 21h 返回Dos 不然会死机
        //除了mov剩下的都是给汇编程序看的 到OBJ只保留了mov文件 所以OBJ文件是最小的
        //汇编 程序分为 指令和伪指令 伪指令是给汇编程序看的 指令是执行的 OBJ只有指令
		
		//定义一个数据(附加段 堆栈段同)段地址 定义段地址 assume指定段类型 手动传递到DS中(段传送)
			不允许把立即数 直接传到段寄存器中 MOV DS,data //这样是错的
				//MOV AX,data MOV DS,AX
    
    	code segment
    		assume cs:code,ds:data
    		start:
    		mov ax,data
    		mov ds,ax
    		
    		//要将数据段 a DB 0,1,2 定义的2放到ax中
    		mov ax,a+2 //现在的地址只能通过a+0这样的方式进行访问
            *//后面这个用不了 mov ax,[0002H] //加[]代表是地址 不然就是将0002H当成数字
    		
    		mov ah,4ch
  			int 21h 
    	code ends
    	data segment
    		DB 0,1,2,3,4 //创建5个字节空间 分别放入0-4
    		DB ?,? //开辟两个字节空空间 
    		DB 100 dup(0)//批量预留100个空间
    		//因为不知道偏移地址 所以要加标号(符号地址)
    		a DB 0,1,2 //0的偏移地址为a 1为a+1 s
    	data ends
    		
    	

```

#### 编写一个汇编语言源程序

```
	
	//汇编程序定义一个代码段 将5传入AX通用寄存器
	//A.asm A.obj .asm .obj .exe都可以省略
	
	edit A.asm 内 
	
        code segment 
			assume cs:code
			startA:
			mov ax,5
			
			mov ah,4ch
			int 21h
        code ends
			end startA
			
		//mov int 是真指令
		//segment assume end ends 伪指令
		//startA 是个标号 符号地址 标记在第一条真指令 为了结束程序
		//startA: mov ax,5 这样也行写在前面 写在前一行也行
			
	退出保存
	masm A.asm 
		//5个回车全部默认
		获得A.obj文件
	
	link A.obj文件
		获得A.exe 可执行文件
		
	运行直接A.exe运行 
	
	debug调试 调试可执行程序
		debug A.exe //进入debug 里面的数都是16位的
		debug命令 //都为一个字母 -q退出 -r看当前寄存器的值 -u向下反汇编 -g执行(要设置中止偏移地址) -d 内存当前数据段
		076A:0000(物理地址) B80500(二进制指令)  存着MOV AX 0005
		MOV ax,5 //占了三字节
		-r
		-u
		-g0003 
		
		
	
```

#### 存储原则

```
		
	上面都是高地址 下面都是低地址 是越来越越大的 大的是高地址 小的是低地址
		//如果要存1和2 用DW 1=0001H 2=0010H
		
		0000H //01H
		0001H //00H
		0002H //10H
		0003H //00H
		
```

#### 加法 存放字母 

```
	
	data segment
      a db 1,2,3,?
	  b db 'A' //将A存放进 存储空间 //任何字母的都是用Ascii码储存 大写A为 41
    data ends
    code segment
       assume cs:code,ds:data
       start:
       mov ax,data
       mov ds,ax

       mov al,0
       add al,a
       add al,a+1
       add al,a+2
       add a+3,al

       mov ah,4ch
       int 21h
    code ends
     end start  
	
	//双操作数add 将源操作数与目的操作数相加 结果放到目的操作数
	//不允许在两个存储空间中 直接操作 例如add a+3,a+2 这样是不对的 -很多指令都是 任何运算都要有寄存器参与(除了立即数传入寄存器 和 存储空间) 
	
```

#### 屏幕输出

```
	
	汇编没有 指令直接 键盘输入输出
	BIOS 中有完成 基本输出输入功能 
	也可以调用DOS完成 //但是windows linux互相用的时候需要兼容
	
	
	使用DOS 功能调用
		//调用原理 DOS里面有很多功能 (用功能号使用 )
		//完成中断调用 才能实现程序的加载 dos功能中断 //int 21h
		//mov ah,4ch  int 21h   //只能用ah存放功能号 之后再中断调用
		
		DOS 功能
			01H 单字符输入 
				//mov ah,01H   int 21h 调用功能 可以录入一个字符(只能一个字符) 存放在Al寄存器中 //带回显的单字符
			07H
				//mov ah,07H //07H 号功能和01H 基本一样 只是没有回显
			02H	屏幕输出 单字符 显示的字符的ASCII码要预先 存放到dl上(只能存放到dl)
				//mov dl,41h   mov ah,02h  int 21h //也可以mov dl,'A' 这样不用记ASCII码 ''是伪指令
				//41H 是A 61H是a 0是30H //注意单位是H 16进制
				
				
	
```

#### 大小写字母转换汇编程序 (减法)

```
	
	sub 目的 源    将目的操作数减去源操作数
	//sub dl,20h   dl寄存器寻址 20h立即数寻址
	
	
	code segment
       assume cs:code
       start:

       mov ah,01h
       int 21h

       sub al,20h

       mov dl,al
       mov ah,02h
       int 21h

       mov ah,4ch
       int 21h
    code ends
     end start  
	
```

#### 输入两个数 并将结果输出到下一行(光标定位)(换行等)

```
	
    code segment
        assume cs:code
        start:
        mov ah,01h
        int 21h
        sub al,30h //接受第一个数字符号 并且减去30H转换成对应的数字

        mov bl,al //转移存储位置 防止覆盖

        mov ah,01h
        int 21h
        sub al,30h  //接受第二个数字符号 同上

        add bl,al //将两个数字相加

        add bl,30h //将结果转换为 数字符号
	
		mov dl,0ah //进行
        mov ah,02h
        int 21h

        mov dl,0dh //
        mov ah,02h
        int 21h

	
        mov dl,bl //存放到dl空间 使用02号功能 进行输出

        mov ah,02h
        int 21h

        mov ah,4ch
        int 21h

    code ends
        end start
	
	//任何一个数字的符号 要想转换成数字本身 必须要减去30H
	
	//换行符 LF CR
	//回车换行符 0AH换行符号 0DH回车符号 20H //使用02功能进行显示
	
```

#### 使用堆栈段保护数据(可以用做交换值)

```
	
	//先进后出 后进先出
	不自己定义堆栈段 就是直接使用系统的堆栈段
	pop push //只允许对16位寄存器的数进行操作 只允许对字进行操作 不可以字节操作 //不可以把一个立即数直接压栈
	push dx //dx属于 源操作数
	pop dx //dx属于 目的操作数
	
	//推荐两种实现交换数据的方法 //使用寄存器过渡 会影响cpu执行速度 所以不推荐
		push AX push BX pop AX pop BX
		XCHG AX,BX 交换他们两个的值
		
```

#### 从0不停加到9 之后不断循环输出(循环)

```
	
	code segment
        assume cs:code
		start:
        mov dl,30h
        
        a:
        	mov ah,02h
        	int 21h
        	inc dl
        	cmp dl,3ah
        	jz start
 		jmp a

        mov ah,4ch
        int 21h

    code ends
    	end start 
    
    
    
    dec 操作数 //操作数自减1
    inc 操作数 //操作数自加1   
    jmp 标志 //跳转回标签 无条件跳转指令
    
    
    cmp 对比
    
    
	
```

#### 从0到9 之后在同一个位置 不停变换 (每次等待)(软件延时 对等待时间不太严格的)

```
	
	code segment
        assume cs:code
        start:
        mov dl,30h

        a:
            mov ah,02h
            int 21h
            inc dl
			
			//回车符
            push dx
            mov dl,0Dh
            mov ah,02h
            int 21h
            
            //下面这一部分是为了 软件延时 但是30000还是很少 最大65535
            //但是因为是16位的 cx最大值只能给65535 
			mov cx,65535
			b:
                dec cx
                cmp cx,0
                jnz b
            
            *//真正实现的软件延时 双重嵌套 注意不要太大 不然会非常非常慢
            mov cx,65535
            b:
                mov bx,20
                c:
                dec bx
                cmp bx,0
                jnz c

            dec cx
            cmp cx,0
            jnz b
            
            pop dx
			
			//对比是否到了9
            cmp dl,3ah
            jz start
        jmp a

        mov ah,4ch
        int 21h

    code ends
        end start 
	
	//0DH 是回车 回到当行开头
	//cpu执行速度很快 我们看不到 
	//cpu等待 不能停下来不然就死机了 软件延时法 硬件延时法(定时计数器)
	//使用高级语言的时候 for循环 尽量从大往小了减 这样效率会高
	
```

#### 0-9同位显示延时 实现按下任意键退出

```
	
	
	0A功能 键盘输入到到缓冲区(键盘输入字符串)
	0B功能 检测键盘状态 如果按下AL==0 没被按下AL==FF 
	//这个标志AL 有点问题
	
	code segment
        assume cs:code
        start:
            mov dl,30h

            a:
                mov ah,02h
                int 21h
                inc dl
				
				//下面这部分是检测 按键是否被按下 位置放到 程序能到达的地方
                mov ah,0Bh
                int 21h
                cmp al,00h
                jnz b


                push dx
                mov dl,0Dh
                mov ah,02h
                int 21h
                pop dx

                cmp dl,3Ah
                jz start

                call dealy
            jmp a

        b:
        mov ah,4ch
        int 21h

        dealy proc near
            push cx
            mov cx,65525
            f:
                push cx
                mov cx,20
                e:
                loop e
                pop cx
            loop f
            pop cx
            ret
        dealy endp

    code ends
        end start



	

	
```

#### 大作业1

```
	
	输入大小写 字母 转换成对应 的小大写 字母
	输出提示输出语句 input a~z or A~Z turn high low input # quit 
	
	data segment
        stringa db 'input a~z or A~Z turn high low input # quit $'
        stringb db 'turn high write:$'
        stringc db 'turn low write:$'
    data ends
    code segment 
        assume cs:code,ds:data
        start:
        mov ax,data
        mov ds,ax

        a:

        lea dx,stringa
        mov ah,09h
        int 21h

        call entera

        mov ah,01h
        int 21h

        call entera

        cmp al,'#'
        jz q

        cmp al,'a'
        jl g

        sub al,20h
        lea dx,stringb

        jmp k
        g:
        add al,20H
        lea dx,stringc

        k:
        mov ah,09H
        int 21h

        mov dl,al
        mov ah,02h
        int 21h

        call entera

        jmp a

        q:
        mov ah,4ch
        int 21h

        entera proc near
            push dx
            push ax
            mov dl,0Ah
            mov ah,02H
            int 21h

            mov dl,0Dh
            mov ah,02H
            int 21h
            pop ax
            pop dx
            ret
        entera endp

    code ends
        end start
	
	
```

#### 大作业3

```
	
	//进制转换
	BL = 12h = 00010010 循环移位 获取第一位 0 之后+30H 调用02号功能
	
	//按位 与或非
        //XOR 亦或
        //AND 与
        //OR 或
        //NOT 
	
	
	mov cx,8
	a:
		把高位变成0 通过 任何数和0与都为0 等等 用与和或
		任何数与0相与都为0  相或 都为本身
		任何数与1相与都为1  相或 都为1
        将特殊位保留 其他位清零 保留的位与1相 不保留的都和0相与
        and 21h,01h   得到的是00000000
        之后移位ROL BX,1 00100100 得到00000000
        //循环移位 和01h相与 
        
        加+30h
	loop a
	
	//没有实际 进行了进制的转化 只是拿出来看了一下 计算机保存的还是二进制代码的
	//从2进制数转到16进制 方法是 0001 0010 转为 16是 12H 可以在移位的时候一次移位4次 这样 可以减少循环次数 只需要循环两次 之后获取高四位和第四位(通过移位后 和00001111相与 清零高位) 再加30h  
	//下面的两个实例 都不能转化 A-FFH 因为 A+30h 到 F+30h都不是 对应的ASCII码 所以转换16进制的时候A-B 需要修正 再加07H
	
	实例
		code segment
            assume cs:code
            start:

            mov bl,12h
            mov cx,8
            a:
                rol bl,1
                mov dl,bl
                and dl,01h

                add dl,30h

                mov ah,02h
                int 21h

            loop a
			
			mov dl,'B'
			mov ah,02h
			int 21h

            mov ah,4ch
            int 21h

        code ends
            end start 
	
	//下面是 2进制转16 
	code segment
        assume cs:code
        start:

        mov bl,12h
        mov cx,2
        a:	
            push cx
            mov cl,4
            rol bl,cl
            mov dl,bl
            and dl,0fh

            add dl,30h

            mov ah,02h
            int 21h
            pop cx
        loop a

        mov dl,'H'
        mov ah,02h
        int 21h

        mov ah,4ch
        int 21h

    code ends
        end start 
        
        
   // 带A-F的转换
   code segment
        assume cs:code
        start:

        mov bl,0Bh
        mov cx,2
        a:	
            push cx
            mov cl,4
            rol bl,cl
            mov dl,bl
            and dl,0fh

            cmp dl,0AH
            jnl b

            add dl,30h
            jmp c
            b:
            add dl,30h
            add dl,07h
            c:
            mov ah,02h
            int 21h
            pop cx
        loop a

        mov dl,''
        mov ah,02h
        int 21h

        mov ah,4ch
        int 21h

    code ends
        end start 
	
```

#### 使用FFH

```
	
	//8086不允许 立即数 以字符开头 可以使用 加个前导0 正常使用
	mov ah,ffh //报错
	mov ah,0FFH //正常
	
```



#### 控制转移指令(jmp cmp)

```
	 
	jmp 无条件 无限 跳转
	 
	cmp 对比数,对比数 //有条件 跳转 条件跳转指令都是 看标志位决定的
        JZ 转移标志 //相等转移
        JNZ 转移标志 //不相等转移
        JGE JNL 转移标志 //大于等于就转移
        JLZ
      条件组合符号 控制转移都是以 j 开头
        (带符号数的) Z //等于 g //大于 l //小于 N //不
        (无符号数的) E //等于 A //大于 B //小于
        //等于 和 不等于 有符号和无符号是
        
        cmp 与 sub是同等功能 的 但是sub会把结果放回目的操作数
        //跳转指令之前不一定是 cmp 但是要有一个影响标志位的东西
        //所以上面的程序里面 DEC cx  cmp cx,0  的cmp是多余了 因为dec也会影响ZF的标志位
        
     loop //无条件 有限循环 //loop的循环次数必须放到 cx寄存器 每一次会自减1
		
        例
        	mov cx,2
        	A:
        	代码段
        	loop A
        	
        	等效于
        	
        	mov cx,2
        	A:
        	代码段
        	dec cx
        	jnz A
        
```

#### 定义子程序

```
	
	//汇编里叫 子程序 
	//call 也属于控制指令
	call 代码名
	
	远属性 far //可以被其他程序调用
	近属性 near //只可以自己的主程序调用 只学这个
	
	delay proc near
		//保存在子程序中使用的寄存器
		重复代码块
		//释放寄存器
		ret
	delay endp
	
	//使用call 子函数名称 调用子程序
	//ret 返回被调用处 相当于高级语言return
	//proc endps 这一对是 定义子程序的 伪指令 delay是名字(一般延时函数是这个)
	//定义的位置可以放到 调用终止 后面  这样位置很好
	
	例 //将显示演示 封装成 子程序 
		code segment
            assume cs:code
            start:
            mov dl,30h

            a:
                mov ah,02h
                int 21h
                inc dl

                push dx
                mov dl,0Dh
                mov ah,02h
                int 21h
				
				//调用 子程序
                call delay

                pop dx
                cmp dl,3ah
                jz start
            jmp a

            mov ah,4ch
            int 21h
			
			//定义子程序
            delay proc near
            	//预先保存寄存器的内容 防止
                push cx
                mov cx,65535
                b:
                    push cx
                    mov cx,20
                    c:
                    loop c
                    pop cx
                loop b
                pop cx
                ret
            delay endp

        code ends
            end start 
		
	
```

#### 逻辑运算类指令

```

	//循环移位指令
	ROL 循环左移
		例 BX = 1010 1010B = AAH
			ROL BX,1 //BX循环左移 结果为 BX=01010101 //1是源操作数 目的操作数是BX 源操作数只能直接写1
			ROL BX,3 这样是错的 
			mov cl,3 ROL BX,cl //移位次数比1大 就要这样写
		
	
	ROR 循环右移 //同上

```

#### 09号功能(显示字符串)

```
	
	//串事先需要用$结尾 串预先要放到 数据段中
	
	data segment
		string db 'hello world!$'
    data ends

    code segment
        assume cs:code,ds:data
        start:
		
		*//定义数据段
        mov ax,data
        mov ds,ax
	
		//9号功能 需要将显示的字符串的首偏移地址 放在dx寄存器中
        lea dx,string  
        mov ah,09h
        int 21h


        mov ah,4ch
        int 21h

    code ends
        end start 
    


```

#### 寻址方式(寻找 操作数[目的操作数 源操作数])

```
	
	 //如果把一个数用[]括起来 那他就是地址 
	 ***之前标号a mov ax,a 可以替换为 mov ax,ds:[0000H]
	
	四种寄存器寻址方式 直接寻址 寄存器寻址 寄存器间接寻址 立即数寻址
	 访问立即数速度很快
	 寄存器寻址 速度次快 数量有限
	 直接寻址 相比前两种慢
	 寄存机间接寻址 相比前两种慢
	
	直接寻址 从内存中找 靠着地址找到数据
	寄存器寻址寄存器  中访问空间 靠着寄存器的名字去寻找
	
	mov al,a //a是在data中定义的 偏移地址   a的寻址方式是直接寻址 al的寻址方式是寄存器寻址
	mov al,bx //s 
	
	lea bx,a  mov al,[BX] //寄存器间接寻址 地址必须是16位的 //只能用BX BP SI DI寄存器
	mov al,5 //源操作数是立即数寻址
	
	mov [bx],[ax] (这个是错的 寄存机间接寻址只能用 BX BP SI DI //AX不能用)
	mov [bx],[bp] (错的 不允许在两个存储单元中间 直接传送 )
		//改成这样是对的 *假设存的都是一个字节  mov al,[bp]  mov [bx],al   
	
    mov [bx],5 (这样是对的 //这条指令 有一个存储空间 和一个 立即数 但是没有经过寄存器[bx]不算寄存器)  //8086立即数寻址可以直接传送到存储空间 可以不经过寄存器 //一个立即数不存在类型s
    
    SI DI 是变址寄存器 BX BP基址寄存器 //都属于间接寻址 
    
    //如果a定义为 dw字
    lea bx,a  mov ax,[bx]
    
   
	
```

#### ASCII码表

![](..\Images\微型计算机原理与接口技术\ascii表.png)

#### 集成芯片

```
	
	因为芯片很脆弱 所以加装了外壳 外壳也有很多封装方式
		DIP封装 双列直插式 封装 //只有两边有引脚 //引脚是直接插到芯片上
		..等
	
	//在画cpu芯片的时候 会有一个缺口表示 上段 
	//引脚是按数字数的 U形状 u字上面空的部分左边是1之后按u型数 共有40条
	
	40 Vcc接正极(+5V直流供电)  1/20 GND接负极 //1/20是共通的 为了控制用电
	
	
	cpu运行 需要 供电 
	
	
```

![](..\Images\微型计算机原理与接口技术\8086cpu引脚.jpg)

#### AD15-AD0引脚(地址和数据复用引脚)

```
	
	16引脚 A地址 D数据 地址和数据引脚
	复用 某个人只能有 一个时间用 不能同时传地址和数据 根据总线周期 分传递什么
	T1发出地址 T2收回地址为传输数据做准备 T3等待响应或取数等等 T4结束
	T1发出后 要收回地址 有一个地址锁存器(锁存芯片) 用来保存地址 地址锁存器之后向外连接(连接的是I/O接口 或 内存) 的是AB 地址总线
	T3收到数据(来自I/O接口 或 内存) 通过收发器 再发到DB中 //与外是双向的 地址永远是单向的
	所有剩下的引脚都 接到CB中 作为控制信号
	38-35 也带S 是 代表cpu的状态引脚  地址和状态复用引脚

```

#### INTA非 INTR NMI (控制中断)

```
	
	低电平有效 
	//用来打断 cpu 工作的
	
	中断分为 内部中断 和 外部中断
		这三个都是外部中断的 外部中断分
			可屏蔽中断 INTR-请求 INTA-响应 
			非屏蔽中断 NMI 非屏蔽输入端
	
```

#### 34BHE引脚

```
	
	高八位数据线选通允许 管理高位数据线的 通过
	
```

#### 33引脚MN/MX非

```
	
	CPU 工作在最小 最大工作时
	
```

#### 8086四大工作条件

```
	
	供电 +5V
	时钟 //标志时间
	复位 reset 初始化
		//CPU收到复位信号 将所有寄存器清零 唯CS赋值FFFFH IP此时为0000H
		那么物理地址是FFFF0H 这个地址也是BIOS程序的地址
	准备好信号 ready //内存 和 接口发送给cpu准备好信号 在引脚22
	
	//cpu只要能正常执行程序 那么cpu就是 正常的
	
```

## 题

### 什么是冯诺依曼机

```
	
	由 
		运算器
		控制器
		存储器 
		输入设备
		输出设备
		组成的 是冯诺依曼设计的 计算机系统
	
```

### 说明以下一些伪指令的作用

```
	
	定义数据类型
	
	DB 定义 字节 
	DQ 定义 4字
	DW 定义 字
	DD 定义 双字
	
```

### 8086微处理器可寻址多少字节存储器

```

	16位机  1978年
	
	2的16 次方 65536B 64k
	//但是地址总线 是20条 可以寻 2的20 次方 可寻址 1MB
	奔腾2 处理器 有36条地址线 可以寻址 64GB存储
	
```

### 8086CPU内部由哪两部分组成

```
	
	BIU 和 EU
        BIU 总线接口单元 
            取数 存数 取指 和CPU外部的 内存 I/O接口进行数据交互
        EU 指令执行单元
            执行指令 进行运算

```

### 8086CPU中 有哪些寄存器 各有什么用途

```
	
	16位 段地址寄存器 CS DS ES SS 
		代码段寄存器 数据段寄存器 堆栈段寄存器 附加段寄存器
	16位 指令指针寄存器 IP 记录下一条指令的偏移地址
	
	16位 通用寄存器 //存储计算中需要的数据 AX BX CX DX
	16位 指针和变址寄存器 BP SP SI DI //间接寻址中用于存放基指和偏移地址
	16位 标志寄存器 //记录每次运算结果特征
	
```

### 微处理器有哪些主要部件组成 功能是什么

```
	
	//就是CPU
	取指 取数 存数
	组成
	    20位地址加法器
		算数逻辑部件ALU	算数运算 逻辑运算
		累加器	存放参加运算的数 中间结果 或 地址
		寄存器组 存放参加运算的数 中间结果 或 地址
		指令指针寄存器IP 存放要执行的下一条指令的偏移地址 每次一条
		段寄存器 存放存储单元的段地址 与偏移地址 组成20位物理地址 
		标志寄存器 存放算数与逻辑运算结果的状态
		时序和控制逻辑部件 对整机的控制
		内部总线 微处理器内部各组件之间 进行数据传输的通道

```

### 说明8086系统中 最小模式 和 最大模式 两种工作方式的主要区别是什么

```
	
	最小模式 控制信号由8086CPU自己控制 
	最大模式 控制信号 由协处理器控制
	
```

### 8086系统为什么要做地址锁存器

```
	
	数据总线 和 地址总线 共用一条
	
```

### 那个标志位控制CPU INTR引脚

```
	
	TF
	
```

### CPU在读写总线周期中 数据在那个机器状态 出现在总线上

```
	
	T2-T4
	
```

### 8086CPU重新启动后 从何处开始执行指令

```
	
	CS = FFFFH
	IP = 0000H
	物理地址FFFF0H
	
```

### 8086CPU的最小模式系统配置包括几部分

```
	
	
	
```

### 8086微处理器 微型计算机 微型计算机系统 有什么联系和区别

```

	微处理机 是 微型计算机系统的 核心 CPU中央处理器 主要负责 算数逻辑运算 执行指令
	微型计算机 是 微处理器 存储器 输入/输出接口 系统总线 组成
	微型计算机系统 是 微型计算机为主体 配上 外部输入输出设备 与 系统软件构成的

```

### 什么是USB

```
	
	通用串行总线
		外部总线的一种
		用作微处理机系统 即插即用 和 热插拔功能
		传输速度快 使用方便 连接灵活
		
	
```

### 计算机的数据可分为

```
	
	数值型 和 非数值型 //前运算 后描述某种特定信息
	
```

### 解释下列名词

```
	
	CPU 中央处理器 计算机系统的控制中心 进行 算数和逻辑运算
	存储器 计算机的记忆单元 存放 指令和数据
	堆栈 先进后出 用于存放需要暂时保管的数据
	IP 指针寄存器 偏移地址
	SP 堆栈指针寄存器 指向当前栈顶单元
	BP 基地址指针寄存器 存放基址
	段地址 内存中的一片区域 用于标记地址
	状态标志 ZF SF OF AF PF CF 反映运算结果
	控制标志 IF DF TF 控制指针变换 单步运行控制
	物理地址 存储器中存储器单元的实际编码地址 是一种绝对地址 8086的地址范围为00000H ~ FFFFFH
	逻辑地址 段地址加偏移地址 组成  段地址*16 + 偏移地址 = 物理地址
	机器语言 计算机可以直接执行 的指令 指令由0 1 组成的一串代码组成 //第一代计算机语言
	汇编语言 助记符表示的二进制代码指令语言 符号化等
	指令 能被计算机识别执行的 二进制代码 规定了计算机的一组操作
	内部总线 CPU内部的部件相互传输的通道
	系统总线 CPU和存储器和I/O接口之间传输数据的通道
	SF 标志位
	OF 溢出
	ZF 是否为0
	IF 允许中断 
	PF 奇偶校验是否补1
	
	
```

### ASCII

```
	
	可以表示128种字符
	
```

### 主频计算

```
	
	8086主频
		5MZH
		10MZH
		
	//频率和周期互为倒数
		5MZH的CPU的时钟周期 等于 1/5M s 将一秒分成5m份 这是一个时钟周期
	
```

### 将5394H与-777FH相加 求标志位

```
	
	5394H = 0101 0011 1001 0100
	-777FH 求补码 
		原码1111 0111 0111 1111
		反码1000 1000 1000 0000
		补码1000 1000 1000 0001
	
	做加法运算
		0101 0011 1001 0100
	+
		1000 1000 1000 0001
	= 	1101 1100 0001 0101
	
	ZF = 0//不为0
	SF = 1//有符号
	OF = 0//没有溢出
	
	
```

### BIU EU组成

```
	
	BIU 
		地址加法器
        段寄存器
        IP偏移地址
        指令队列缓冲
        I/O控制电路
	EU
		ALU 算数逻辑(运算器)
		PSW标志寄存器
		运算寄存器
		通用寄存器
		
```

### 逻辑地址求物理地址

```
	
	1000H:2000H
		10000H + 2000H
		12000H
	2000H:1000H
		20000H + 1000H
		21000H
	1A00H:B000H
		1A000 + B000H //注意转成二进制加 或者满16进1
		25000H
	3456H:AB09H
		34560H + AB09H
		3F069H
	
	
```

### 填空

```
	
	在EU中起数据加工与处理作用的功能部件是 ALU
	以下不属于BIU中的功能部件是 地址寄存器 
	指令指针寄存器(IP)中存放的内容是 下一条指令地址
	8086 系统可访问的内存空间范围是 00000H-FFFFFH
	8086的I/0地址空间采用16位数寻址时 可访问的端门数容量为 2的16次方 64KB
	8086最大和最小工作方式的主要差别是 单处理器与多处理器的不同
	8086的内部结构由EU和BIU组成 前者功能是执行指令 后者功能是总线操作
	8086取指令时 选取CS作为段基值 再加上IP 提供的偏移地址形成20位物理地址
	8086的标志寄存器 共有9个标志位 分为6个状态标志位 和 3个控制标志位 
	逻辑地址为1000H:0230H时 其物理地址是10230H 段地址是1000H 偏移量是0230H
	段地址33A0H 偏移地址0130H 物理地址是33B30H
	时钟周期 是指 CPU基本时间计量单位 总线周期 是指一次总线操作时间
	代码段是什么 是内存中的一个端 代码段寄存器是CS CS不是代码段 是寄存器
	EU执行部件从 指令队列 取出指令代码 执行该指令
	队列已满 执行部件又不使用总线 总线接口部件进入空闲状态
	执行 转移指令 调用指令 返回指令 先清空队列内容 再将要执行的指令放入队列中
	
```



### 判断题

```
	
    //对
	计算机中带符号数采用补码表示的目的是为了简化机器数的运算。 
	计算机地址总线的宽度决定了内存容量的大小。
	从内存单元偶地址开始存放的数据称为规则字
	8086系统 复位后重新启动时 从内存地址FFFF0H处开始执行
	
	//错
	计算机中数据的表示范围不受计算机字长的限制。
	计算机键盘输入的各类符号在计算机内部均表示为ASCII码。(只是传输使用)
	
	
```



## 杂乱或无法分类

```
	
	//32位cpu装win7 64肯定装不上的 
		//低位数不能装高位数操作系统
		//高位数可以装低位数操作系统
		
	//完全发挥64位CPU 需要
		//操作系统64
		//内存32GB
		//应用软件64位
	
	//64位cpu地址线 只用了40条(根据技术也有36根的52根的) 没有到64条  
	
	//网络的单位是bps b/s 每秒多少个位(注意是b)
		//例如300MB的文件 300bps下要下 8秒   1B = 8bit
	
```

```
	

		
	
```



```
	
	//取消 度娘栏 简化内容 笔记只 记录 重要的纲要结构 自己读懂就好 但是要有良好的纲要结构 保持高度可读性
	/总结的图片 最后是学完之后或者 有大部分内容了之后 凭借感觉选的图
	
```

