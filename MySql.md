```
	2019年4月22日14:28:10创建
	2021年10月19日17:26:47 - 2021年11月28日18:53:37 第二次校增
	2021年11月3日22:58:41 CAHRSET 更正 CHARSET
```

# 目录

[TOC]

# MySql

### MySql数据库的基本介绍

#### 简介

```
	
	瑞典 MySQL AB公司开发》2008年被SUN公司收购》在2009年SUN公司被甲骨文(Orecle)公司收购
	分为 社区版 和 免费版 默认端口3306
	图形化软件Navicat
	
```

#### 安装(卸载)

```xml
	
	https://dev.mysql.com/downloads/mysql/
	添加环境变量path mysql-8.0.26-winx64\bin
	在zip解压路径新建my.ini配置文件----配置端口号以及zip解压目录(目录用\)
	在MysqL安装目录的 bin 目录下执行命令  MysqLd --initialize --console //尽量用管理员cmd
		--cmd切换盘符直接输入盘符 之后cd 进入到目录
		--执行返回结果 [MY-010454] 后面的是 密码
	分配服务名 MysqLd --install MysqL8.0(可替换).
		-通过命令sc delete MysqL8.0 或 MysqL8.0 -remove 卸载 MysqL 服务
	开启服务 net start mysql8.0
	ALTER USER 'root'@'localhost' IDENTIFIED WITH MysqL_native_password BY 'newpass';设置新密码
	
	//安装出现问题可以尝试将C:/ProgramData目录下的MySQL文件夹删除
	//安装客户端图形化工具 Navicat
	
	--关于同时安装 mysql8 和 mysql5
		端口mysql5设置成 3306  mysql8设置成 3307
		环境变量可以都不设置 因为设置了两个 就需要互相改直接用 图形化界面更简单些
		同时安装都是使用上面的配置 一些配置两个版本的数据库岔开就行
			//注意安装另一个时把第一个服务关掉
			// mysql5 的安装操作要换成 执行mysqld --initialize --console命令后再执行mysqld install
			//更改密码一样 可能低版本的不一样
    
    
    //my.ini 	记录MySQL配置信息 可修改配置内容 如端口号  字符集 
	//修改MySQL配置文件 必须重启MySQL后 修改的内容才能生效
    
    my.ini
    
[MysqLd]

# 设置3307端口

port=3307

# 设置MysqL的安装目录

basedir=E:\\software\\MysqL\\MysqL-8.0.11-winx64 # 切记此处一定要用双斜杠\\，单斜杠我这里会出错，不过看别人的教程，有的是单斜杠。自己尝试吧

# 设置MysqL数据库的数据的存放目录

datadir=E:\\software\\MysqL\\MysqL-8.0.11-winx64\\Data # 此处同上

# 允许最大连接数

max_connections=200

# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统

max_connect_errors=10

# 服务端使用的字符集默认为UTF8

character-set-server=utf8

# 创建新表时将使用的默认存储引擎

default-storage-engine=INNODB

# 默认使用“MysqL_native_password”插件认证

default_authentication_plugin=MysqL_native_password
    
```

#### 登录 退出

```

	登录
	 mysql -uroot -p密码
	 mysql -hip -uroot -p连接目标的密码
	 mysql --host=ip --user=root --password=连接目标的密码
	
	退出
		quit
		exit
		\q
		
	\c 可以清除以前的命令
	
```

#### 三种注释

```
	
	单行注释	
	 	-- 注释内容	 
	 	# 注释内容
	多行注释	
        /* 注释 */
	
```

#### 数据(数值)类型

```
	
	类型	 	   说明(有符号的取值范围)(无符号) 					 储存需求
	
	TINYINT     非常小的数据(-128~127)(0~255) 					1字节
	SMALLINT    较小的数据(-32768~32767)(0~65535)				 2字节
	MEDIUMINT   中等大小的数据(-8388608~8388607)(0~16777215)       3字节
	INT         标准整数(-2147483648~2147483647)(0~4294967295)    4字节
	BIGINT      较大整数      						  			  8字节
	FLOAT		单精度浮点数						 4字节
	DOUBLE		双精度浮点数						 8字节
	DECIMAL(定数类型)   字符串形式的浮点数   M+2个字节   //取值范围 Decimal(M,D) M整数位 D小数位 表示小数点后的位数
	
	//可以在命令提示符中 用 help 数据类型; 来查询类型的取值范围
	//当对数据的精度要求非常高 如果用来储存货币数据 可以选择DECIMAL 它比DOUBLE类型的精度还要高
	
	
	字符串类型 		说明 		       长度
	
	CHAR[(M)]		定长数组	     M字节
	VARCHAR[(M)] 	可变字符串	    可变长度
	TINYTEXT	    微型文本串	    0~256字节
	TEXT 		    文本串 		 0~65535字节  
	BLOB 		    二进制字符       0~65535字节
	
	//TEXT 和 BLOB 都用于储存 比较大的数据 TEXT类型(储存文本字符串 正文) BLOB类型(储存二进制字符串 图片或音乐)
	 
	
	日期类型		格式		取值范围
	
	DATE    	YYYY-MM-DD 		   1000-01-01 ~ 9999-12-31
	DATETIME	YY-MM-DD hh:mm:ss 	1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
	TIME		hh:mm:ss		   -835:59:59 ~ 898:59:59
	TIMESTAMP    YYYYMMDDHHMMSS     1970年某时刻~2038某时刻精度为1秒
	YEAR		YYYY格式的年份    	1901~2155
 	
 	ENUM类型 储存 单选项 形式的数据
 		定义的选项值不能重复 选项值必须是字符串文字 
 	
 	
   //若某日期字段默认值为当前日期 一般设置为TIMESTAMP类型 该段未插入数据时 默认为系统当前时间
   //在存数据时 允许 不严格语法 任何标点符号都可以用作日期部分之间的间隔符 
   例 11-01-12 11@01@12 这些值也可以插入到数据库 
   
```

### SQL语句(SQL的全称是结构化查询语言)

#### SQL的分类	

```mysql
	
	DDL(Data Definition Language)数据定义语言 	操作数据库和表
	//用来定义数据库对象		数据库、表、列等	关键字create、drop、alter等
	
	DML(Data Manipulation Language)数据操作语言	增删改表中数据
	//用来对数据库中表的数据进行增删改		关键字insert、delete、update等
	
	DQL(Data Query Language)数据查询语言	查询表中数据
	//用来查询数据库中表的记录(数据)		关键字select、where等
	//数据库语言中最核心最重要的语句使用频率最高的语句
	//简单的单表查询或多表的复杂查询和嵌套查询
	
	DCL(Data Control Language)数据控制语言(了解) 	管理用户授权
	//用来定义数据库的访问权限和安全级别,及创建用户	关键字GRANT、REVOKE等
	
```

```mysql

	通过执行SQL语句的结果分析
	Query OK,1 row affected(0.00sec)
		//Query OK 代表语句执行成功
		//1 row affected 表示操作影响的行数
		//0.00sec 表示操作执行时间
	
```

```mysql
	
	Structured Query Language 	结构化查询语言
	//就是定义了 操作 所有 关系型数据库 的规则	每一种数据库操作的方式存在不一样的地方 称为"方言"
	
	SQL通用语法
	 //SQL语句可以单行或多行书写 以分号结尾
	 //可使用空格和缩进增强语句的可读性
	 //MySQL 数据库的 SQL 语句不区分大小写 	关键字建议使用大写
	
```

#### DQL查询数据语法

```
	
	//[]为可选的	{}为必须的  ...省略
	//语句执行顺序FROM>WHERE>SELECT>ORDER BY
	
	SELECT语法
	 SELECT { * 或 某个属性的名字(该段可为多个)}  //字段可以为数学表达式 可以进行数值计算
	 FROM 表名 //表可以有多个','隔开
	 WHERE 条件//指定结果需满足的条件
	 GROUP BY 字段//指定结果按那几个字段来分组
	 HAVING	//过滤分组的记录必须满足的次要条件
	 ORDER BY 字段//指定查询记录按一个或者多个条件排序
	 LIMIT [位置偏移量],行数 //指定查询的记录从那条到哪条 位置偏移量不写从 0开始
	
	 例
	  查询表中所有的数据列结果 
	   SELECT * FROM 表名
	   
	  指定查询的结果数据列名称
	   SELECT * 数据列名称(字段名),数据列名称(字段名),数据列名称(字段名)
	   
	  区分连接查询时两个表有同名的字段
	   SELECT * 表名称.字段名,表名称.字段名
	
```

##### 字段名名称和关键字重复

```mysql

	SELECT NAME FROM employees; //NAME 会被识别成关键字
	
	SELECT `NAME` FROM employees; //将NAME 用`引起来
	
```

##### AS 添加表别名

```mysql
	
	 可给数据列取一个新别名
	 可给表取一个新别名
	 可把经计算或总结的结果用另外一个新名称来代替
	 //AS 也可省略不写 会有特殊情况出现错误 不建议省略
	 //当为某个表命名了别名后 在SELECT语句中 出现该表的字段需要指定表名时,就必须统一使用该表的别名,否则会产生语法错误
	 
	 
	 例
	  SELECT 字段名 AS "学号" FROM 表名; //字符段别名
	  SELECT 字段名 FROM 表名 AS "a"; //表别名 之后利用表别名加 . 可以调出表中的字符段
	  
	  使用表别名 
	  SELECT * FROM 表名1 AS a INNER JOIN 表名2 AS b ON a.字符段 = b.字符段 GROUP BY a.字符段,a.字符段;
		
```

##### DISTINCT 关键字

```mysql
	
	去掉SELECT查询返回的记录结果中重复的记录	
	 //列值相同 只返回一条    ALL 关键字是默认的 返回全部记录
	 //注意 如果有多个字段则 以字段的组合结果去重 
	 
	 语法
	 SELECT DISTINCT 字段名,字段名 FROM 表名;
	 
	 例
	  查询成绩表中的所包含的课程ID
	  
	 //当DISTINCT 语句后面有两个字段 表示多个字段间组合值 去掉重复
	  查询员工有多少个不同的姓名
	  SELECT DISTINCT  字段名 , 字段名 `employees`;
	 
```

##### WHERE 条件语句

```mysql
	
	用于检索数据表中符合条件的记录
	//搜索条件可由一个或多个逻辑表达式组成,结果一般为真或假
	//搜索条件的组成	比较操作符 逻辑操作符
	
	运算符
	 =               等于
	 <> 或 !=        不等于
	 >			    大于
	 <			    小于
	 >=              大于等于
	 <=              小于等于
	 <=>			两个表达式彼此相等或都等于空值 值为TRUE
	 
    算术运算符
	 可以在字段中 + - * / %
	 //除法和求余 运算 除数为0 是 非法运算 返回结果为NULL
	 //这五个算术运算符 有NULL参与运算 计算结果都为NULL 可以用IFNULL() 替换NULL值  
        
 	逻辑操作符
	 And或&&		a AND b 或 a && b	逻辑与
	 OR或||		a OR b 或 a||b		逻辑或
	 NOT或! 		NOT a 或 !a			逻辑非 //反结果放在 筛选字段 和 条件之前
	 XOR或^		a XOR b				逻辑异或 //两个值不同则返回1否则0

    注! 用 and 和 or 关键字写条件时 and的优先级 比or高 可以用括号提升优先级 或者使用其它操作符
    
    比较操作符
     IS NULL	 	   a IS NULL		   		若操作符为NULL 则结果为真
     IS NOT NULL       a IS NOT NULL	   		若操作符不为NULL 则结果为真
 	 BETWEEN		   a BETWEEN b AND c 		若a数值范围在b与c之间则结果为真
	 IN				   a IN(a1,a2,a3,...) 		若a等于a1,a2...中的某一个则结果为真
     LIKE 			   a LIKE b					SQL模式匹配  若a匹配b  则结果为真
	
	位运算符
	 //-
	
	//数值数据类型的记录之间才能进行算术运算
	//相同数据类型的数据之间才能进行比较

    NULL
     NULL代表"无值" 或 "未知值"
     区别于零值0和空符串
     不要用NULL进行算数运算 结果仍为NULL
     在MySQL中 0或NULL都意味着假 1为真
     只能出现在定义允许为NULL的字段
	 须使用 IS NULL 或 IS NOT NULL 比较操作符去比较

	查询年龄大于20岁
	SELECT * FROM student WHERE age > 20;

	查询年龄不等于20岁
	SELECT * FROM student WHERE age != 20;
	SELECT * FROM student WHERE age <> 20;
	
	查询年龄大于等于20 小于等于30
	SELECT * FROM student WHERE age >= 20 &&  age <=30;
	SELECT * FROM student WHERE age >= 20 AND  age <=30;
	SELECT * FROM student WHERE age BETWEEN 20 AND 30;

	查询年龄22岁 18岁 25岁的信息
	SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25;
	SELECT * FROM student WHERE age IN(22,18,25);
	
	查询英语成绩为null
	SELECT * FROM student WHERE english IS NULL;
	
	查询英语成绩不为null
	SELECT * FROM student WHERE english  IS NOT NULL;
	
```

###### BETWEEN(根据一个范围值来检索)   

```mysql
	
	SELECT ...	FROM 表名 WHERE 查询范围字段 BETWEEN 值1 AND 值2; 
	 //查询课程表中  查询范围字段名  在值1和值2之间的所有记录 包括值1和值2(使用NOT时 查询结果不包括开始值和结束值)
	 //注意AND不能改为&&
	 
```

###### IN进行范围查询

```mysql
	
	SELECT ...	FROM 表名 WHERE 查询范围字段名 IN(值1,值2);
	SELECT ...	FROM 表名 WHERE 查询范围字段名=值1 OR 查询范围字段名=值2; //与上等价
	 //查询的字段x的值,至少与括号中的一个值相同
	 //多个值之间用英文逗号隔开
     
```

###### LIKE模糊查询

```mysql
	
	SELECT ...	FROM 表名 WHERE 查询模糊范围字段名 LIKE "%";
	 //与"%"一起使用 表示匹配0或任意多个字符
	 //放的位置和数据的格式有关
	 
	SELECT ...	FROM 表名 WHERE 查询模糊范围字段名 LIKE "%#_" escape "可定义转义字符#";
	 //escape 可以定义转义字符 如果表达式需要匹配的数据内有下划线 此时_只是代表下划线
	 
	SELECT ...	FROM 表名 WHERE 查询模糊范围字段名 LIKE "_";
	 //与"_"一起使用 表示匹配单个字符
	 
	 //REGEXP运算符 可以进行比LIKE更 详细的匹配
	 
   例
	查询姓名是3个字的人
	SELECT * FROM student WHERE NAME LIKE "___";
	
	查询姓名中包含德的人
	SELECT * FROM student WHERE NAME LIKE "%德%";
	
	查询姓名第二个字是化的人
	SELECT * FROM student WHERE NAME LIKE "_化%";
	
	查询姓马的有哪些
	SELECT * FROM student WHERE NAME LIKE "马%";
	
```

###### 子查询

```
	
	子查询是一个嵌套在SELECT INSERT UPDATE 或 DELETE 语句或其他子查询中的查询
	
	将子查询的结果作为父查询的一部分参加 操作
	
	//子查询 灵活 方便 常做增删改查的条件适合操纵一个表的数据  表连接更适合于查看多表的数据
	
	单行单列 比较运算符 
	多行单列 IN关键字
	多行多列 放在FROM后面 作为一张表再次查询
	
	//在出现在FROM子句中 的子查询 必须指定表别名 一般返回多行多列数据记录 可以当做一张临时表
	//任何允许使用表达式的地方都可以使用子查询
	//子查询可以在 SELECT / FROM / WHERE / GROUP / HAVING  
	//子查询和比较运算符联合使用 子查询结果必须是一个值 IN 除外
	//先执行子查询 返回来自子查询的结果
	//嵌套查询可由多个子查询组成 求解的方式是由里及外
	//先执行子查询返回查询的结果 再执行外围的父查询 返回查询的最终结果
	//子查询和比较运算符联合使用 EXISTS子查询结果不必须是一个字段 * 也可行
	//父查询的查询结果和子查询没有直接关系
	
```

###### IN 子查询

```
	
	SELECT ... FROM 表名 WHERE 字段 比较运算符 (子查询);
	SELECT ... FROM 子查询 WHERE 字段 比较运算符;
	
	子查询返回的结果一般都是集合 故而建议使用 IN 关键字
	//可以返回多条记录
	
	SELECT ... FROM 表名 WHERE 字段 IN(子查询);
	
	NOT IN 子查询
	
	SELECT ... FROM 表名 WHERE 字段 NOT IN(子查询);
	
```

###### ALL ANY 查询


```

    ALL 与子查询返回的所有值 比较为true 则返回为true
    ANY 与子查询返回的任意值 比较为true 则返回为true
    SOME是ANY的别称很少用

```

###### EXISTS 关键字的应用(判断数据库存在等等)(EXISTS子查询)

```
	
	//利用IF EXISTS/IF NOT EXISTS 判断表/库是否存在 之后进行删除等等(可以看成返回值TRUE/FALSE)
	例 DROP DATABASE IF EXISTS 表名; 
	如果数据库存在 则删除数据库
	例 CREATE DATABEL IF NOT EXISTS 表名;
	如果数据库不存在则创建表
	
	//EXISTS 子查询
	SELECT ... FROM 表名 WHERE EXISTS(子查询);
	 子查询有返回结果    EXISTS 子查询结果为TRUE 
	 子查询没有返回结果  EXISTS 子查询结果为FALSE ,外层查询不执行
	
	NOT EXISTS
	//相对于 EXISTS的 结果 相当于!(非EXISTS结果)
	
```

##### ORDER BY (指定结果按那几个字段来排序)

```

	可以单独出现 如果和WHERE同时出现要在WHERE语句之后
    //可以实现每列使用不同的排列方式
    //空值记录将被排在最前面
    //多个排序条件根据先后顺序进行排列先排序前面的 再排序后面的
    //多个排序条件 前边的条件值一样时 才会判断第二条件
	
	按照字段名或字段顺序(健壮性低不推荐生产) 升序排序 升序ASC(默认) 降序DESC
	SELECT * FROM 表名 WHERE ... ORDER BY 排序字段名 ASC;
	SELECT * FROM 表名 WHERE ...
ORDER BY 字段在表中的顺序 ASC;
	
	多字段排序
	SELECT * FROM 表名 ORDER BY 字段名 DESC, 字段名1 DESC;
	
```

##### GROUP BY (指定查询记录按一个或者多个条件分组)

```mysql
	
	在分组语句中 SELECT字段列表 必须 是GROUP BY 子句中出现的字段,或者是某个字段的聚合函数值 //会返回一些不符合预期的结果 (AVG()求平均值时 虽然查询出来是不能区别各个组的 但是 AVG是可以的)
	
	查询统计男女员工人数
	SELECT gender AS "性别" , COUNT(1) FROM 表名 GROUP BY gender;
	
	查询 60 后 员工中的男 女人数
	SELECT "60后" AS "出生年代" , gender AS "性别",COUNT(1) AS "人数" FROM 表名 WHERE birth_date BETWEEN "1960-01-01" AND "1969-12-31" GROUP BY gender ;
	
	查询并统计名字的员工人数
	SELECT first_name AS "名" , COUNT(1) FROM 表名 GROUP BY first_name;
	
	查询男女员工中年龄最大年龄最大员工的出生日期
	SELECT gender , MIN(birth_date) AS "最大员工出生日期" , COUNT(1) AS "人数" FROM 表名   GROUP BY gender;
	
	//注意年龄和出生日期的关系
	//分组可以为多个字段 之间用,隔开
	
```

###### HAVING (过滤分组的记录必须满足的次要条件)

```mysql
	
	查询并统计名字是Mary的员工人数
	SELECT first_name AS "名字", COUNT(1) AS "人数" FROM 表名 GROUP BY first_name HAVING first_name = "Mary";
	
	查询并统计各个名字的员工人数 显示 名字人数 >= 10的
	SELECT first_name AS "名字" , COUNT(1) AS "人数" FROM employees GROUP BY first_name HAVING 人数 >= 10;
	
	WHERE和HAVING的区别
		
		HAVING子句的筛选字段 必须是 (SELECT)GROUP BY中出现的字段 或者是某字段的聚合函数值 //不是会报错
		
		WHERE在分组之前进行限定 
		HAVING在分组之后进行
		//先筛选后分分组 WHERE限定 如果不满足结果 则不会被查询出来
		
		WHERE 后不可以跟聚合函数  HAVING可以进行聚合函数的判断
		
```

##### LIMIT分页查询

```
	
	//限制SELECT 返回结果的行数 //记录条数索引从0开始 
	
	语法例子
	 SELECT * FROM 表名 LIMIT 5; //返回前5条记录
	 SELECT * FROM 表名 LIMIT 5,10; //返回 6 ~ 15条  LIMIT 开始的索引,查询的条数 从开始数
	
	公式 开始的索引((当前的页码 - 1) * 每页显示的条数)  每页显示的条数
	//LIMIT 是一MYSQL方言 //开始的索引也叫 位置6tgv6偏移量 
	
```

##### MySQL连接查询(多表查询)(分成两类)

```
	
	//如需要多张数据表的数据进行查询，则可通过连接运算符实现多个查询
	//可以给表别名 之后使用别名 快速 便于引用
	//多表直之间能否进行关联查询 是依据各表之间是否存在关联关系,一般是"主-外键"关系,只有具备关联关系的表才能进行关联查询
	//表连接更适合于查看多表的数据
	
	//如果不声明JOIN的类型 默认为INNER JOIN 的联接
	
```

###### 内连接 INNER JOIN

```
	
	如果表中有至少一个匹配 则返回所有匹配的行
	
	自身连接查询 //如要有多个字段要求相同 用 AND(&&效果一致)
      INNER JOIN 在表中至少一个匹配时 返回记录   //INNER JOIN 与 JOIN 是相同的
      SELECT 字段 FROM 表名1 INNER JOIN 表名2 ON 表名1.字段 = 表名2.字段
	
	//使用WHERE 也可以给出连接条件 有些时候会影响查询性能
		SELECT 字段 FROM 表名1,表名2 WHERE 表名1.字段 = 表名2.字段
	
	等值和非等值的连接查询 //多个表放到FROM后 用逗号隔开 //搜索空间过大不建议使用
	  非等值连接查询 //返回记录数为两表记录数的乘积
	  	//笛卡尔积  有两个集合A,B  取这两个集合的所有组成情况
	  	//要完成多表查询，需要使用WHERE消除无用的数据
	    SELECT 字段1 , 字段2 FROM 表名1,表名2;
	  等值查询 //等效于内连接
	   SELECT 字段1 , 字段2 FROM 表名1,表名2 WHERE 表名1.字段1 = 表名2.字段2;
	
	//ON关键字后面给出 2 个表的关联条件  一般是主-外键关系 以便对应唯一
	//自连接查询 可以自己将一个表设置两个别名 进行内连接查询 
	
```

###### 外连接 OUTER JOIN

```
	
	以JOIN分左右表
	
	//OUTER 可以和INNER一样省略不写  
	//注意 连接的条件可以有多个 可以用and这样的关键字
	
    左连接 LEFT JOIN
     以左表为基准,返回右表所有记录,右表 不满足连接条件的记录 也将返回NULL值(例有一条记录为NULL)返回
     SELECT 字段 FROM 表名1 LEFT OUTER JOIN 表名2 ON 表名1.字段 = 表名2.字段
     
     //从左表中返回所有的记录，即便在右表中没有匹配的行 不满足的行值为 null
     
	右连接 RIGHT JOIN
	 以右表为基准,返回左表所有记录,左表 不满足连接条件的记录 也将返回NULL值(例有一条记录为NULL)返回
	 SELECT 字段 FROM 表名1 RIGHT OUTER JOIN 表名2 ON 表名1.字段 = 表名2.字段
     
     //从右表中返回所有的记录 即便在左边中没有匹配的行 不满足的行值为 null
     
```

##### UNION合并查询结果

```
	
	SELECT * FROM 表名 UNION SELECT * FROM 表名;
	//UNION 将查询结果 合并 并将重复的记录删除
	
	SELECT * FROM 表名 UNION ALL SELECT * FROM 表名;
	//UNION ALL 将查询结果 合并 重复的记录不删除

```

##### 条件判断函数

```mysql
	
	IF(条件表达式,A,B) //条件为true 返回A 否B
	
	IFNULL(A,B) //如果A为NULL则返回B 如果
	
	
	
	//用在 查询资源列表中替换查询结果 
	例 SELECT IF(字段名 > 60,'及格','不及格') FROM 表名;
	
	Case函数 //有两种用法
	
	CASE WHEN 条件表达式 THEN A ELSE B END //判断真假
	CASE 条件表达式 WHEN A THEN A1 WHEN B THEN B2 ELSE C END //判断值

```

##### JSON函数 //待补充

```
	
	https://blog.csdn.net/szxiaohe/article/details/82772881
	
```

##### MySQL的统计函数(大部分都为处理字段)(如果"()"留空根据其作用判断是否有参)

###### 聚合函数

```
	
	COUNT()		返回满足SELECT条件的记录总行数
	//SELECT COUNT(*) ... 不建议使用*效率低 这样写为最高效率 count(1) 1可为任意值
	//计算函数和对比函数会忽略NULL
	
	SUM()			返回字段的总和 返回数字字段 表达式列 做统计 
	
	AVG()   		返回字段的平均值 通常为数值字符 表达式列 做统计 
		
	MAX()			返回字段最大的值 可以为数值字段 字符字段 表达式列 做统计 
	
	MIN()			返回字段最小的值 可以为数值字段 字符字段 表达式列 做统计 
	
	ABS()			返回绝对值
	
	MOD(x,y)        返回数值x除以数值y后的余数
	
	STD()或STDDEV()	返回该列的标准差
	
	VARIANCE()		返回该列的方差
	
	GROUP_CONCAT()	返回列值连接组合成的一个字符串(用逗号分隔开) 最大长度为1024
	
	CEIL(x)			返回大于或等于数值x的最小整数		例 CEIL(2.3)  返回3

	FLOOR(x)		返回小于或等于数值x的最大整数 	例 CEIL(2.3)  返回2

	RAND()			返回0~1间的随机数				 值例 0.5525468583708134
	
	//例生成100内的随机数 ROUND(RAND()*100,0)
	
	ROUND(x,y)		返回对参数 四舍五入 的值 ROUND(返回整数) y参数是四舍五入后保留几位小数
	
	TRUNCATE(x,y)	对x截取 保留小数点后y位 不会四舍五入直接截取 TRUNCATE(1.42,1) 1.4
	
```

###### 字符串函数

```
	
	() 中填字段 或者参数 第几个    //有多个参数的方法 这里只记录几个例子
	
	CONCAT(字符串,字符串)       字符串连接  CONCAT('My','S','QL') <==> MySQL //参数中有一个为NULL则值为NULL
  	
  	INSERT(字符串,第几个开始,数几个(包括开始本身),"替换成的字符串") 字符串替换  

   LOWER(字符串)			   将字符串转为小写

	UPPER(字符串)			   将字符串转为大写
	
	SUBSTRING(字符串,第几个开始,数几个(包括开始本身))	字符串截取
	
	REVERSE(字符串)  		   反转字符串
	
	LENGTH(字符串)			   返回字符串长度或字符个数 //一个汉字占用2字节 英文占1位
	
	LTRIM(str)            去除左空格函数
	
	RTRIM(str)            去除右空格函数
	
	trim()                函数可以过滤指定的字符串 //没有参数时默认去除空格
	
```

###### 时间日期函数

```
		
   CURDATE()		获取当前日期			值例 2016-08-08

   CURTIME()		获取当前时间			值例 19:19:26

    NOW()           获取当前日期和时间	   值例 2019-05-05 21:19:26

	WEEK(date)       返回日期date为一年中的第几周	值例 26

   YEAR(date)  	 返回日期date的年份  			值例 2019

	HOUR(time)		返回时间time的小时值	       值例 9

	MINUTE(time)	返回时间time的分钟值		   值例 43
	
	SECOND()		...	
	
	DATEDIFF(date1,date2)		返回日期参数date1和date2之间相隔的天数 	值例 2333

	ADDDATE(date,n)			    计算日期参数date加上n天后的日期		值例 2019-06-05 21:19:26
	
	DATE_FORMAT(data, 参数列表)	//格式化日期函数 具体参数 例子 DATE_FORMAT(data, '%y %M')	
		%Y/%y 四位数/两位数形式的年份 %c/%M/%m 数字(0~12)/英文/数字(00~12)形式的月份
		%月省略 %j一年中的第几日(001~366) %H(00~23)/%h(01~12)/%r(01~12后缀为AM/PM 上午和下午)
		%i/%S 两位数字形式的分(0~59)/秒(0~59)
		
	TIME_TO_SEC(TIME) //将time转化成秒
	SEC_TO_TIME(SEC) //将秒切换为HH:MM:SS形式
	
```

#### DQL查询的一些实例

```
	
	取得 每个部门 最高薪水 的人员 名称 
		//根据部门分组 找出每个分组薪水的最大值
		//将结果当作临时表 和 人员工资表进行连接 连接条件 为 部门编号等于部门编号 并且 最大值的工资等于工资
	
	哪些人 的薪水在 部门的 平均薪水之上
		//找出每个部门的平均薪水
		//将结果当作临时表 和 人员工资表进行连接 连接条件 为 部门编号等于部门编号 并且 工资大于平均工资
		
	不使用组函数MAX() 取得最高薪水
		//1 查询出所有数据 之后用薪水降序排列 之后limit 1 (只要最高薪水 要人员名称可以使用子查询)
		//2 表的自连接 自连接表 连接条件为 a表 小于 b表 这样出来的所有数据中 不会包含最大值 之后使用 NOT IN(自连接)找出最大薪水

	//使用 表连接 的 on 后面可以有多个 条件 可以用来综合查询一些 薪资等级一些的问题 
    
```

#### DML数据操作语言(增删改查)(有返回值 返回为(操作的行数 或者 0))

##### INSERT INTO 添加数据语句 

```
	
	 INSERT INTO 表名(字段1,字段2...) VALUES(值1,值2,...); //指定字段
	 INSERT INTO 表名 VALUES(值1,值2...); //不指定字段插入数据
	 INSERT INTO 表名(字段列) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...); //插入多条数据
	 
	 //字段或值之间用英文逗号隔开
	 //除了数字类型 其他类型需要使用引号(单双都可以)引起来
	 //不定义列名 则默认给所有列添加值 如果插入的是表中部分数据 字段名列表必填
	 //表名(字段列)可以省略 但添加的值 必需与 表结构数据 列顺序 数量 一致 
	 //指定插入列 可以部分指定 没有指定的值采取默认值 没有约束会被设为NULL 有约束取对应值
	 //VALUES 可以插入多条数据 VALUE 只能插入一条
	 
```

##### 组合语句将查询结果插入新表

```
	
	//创建表 和 添加数据二步到位
	...省略表创建
	INSERT INTO 新表(字段1,字段2......)
	SELECT 字段1,字段2...... FROM 原表;
	
	//创建表 和 添加数据一步到位
	CREATE TABLE 要添加数据表名(
	SELECT 字段1,字段2...... FROM 复制数据的表名
    )
    
    //两张表的字段名可以不一样 数据类型必须一样
	
```

##### UPDATE 更新数据语句

```
	
	UPDATE 表名 SET 更改的字段列名 = 新值 WHERE 筛选条件;
	UPDATE 表名 SET 更改列名1 = value,更改列名2 = value WHERE 筛选条件;
	//如果不指定筛选条件 将更改此表所有该列的值
	//可以更改多列 用 "," 隔开
	
```

##### DELETE 删除数据语句

```
	
	DELETE FROM 表名 WHERE 条件;
	//没筛选条件 则删除所有列
	//加了筛选条件 则只删除对应的记录(一行)
	//删除所有记录 有多少条记录就会执行多少次删除操作
	
```

##### TRUNCATE 清空表数据

```
	
	TRUNCATE 表名 ;
	//完全清空表数据,但表结构 索引 约束 等不变
	//删除所有记录 先删除表,然后再创建一张一样的表
	
```

##### DELETE 和 TRUNCATE 的区别

```
	
	相同
	 都能删除数据 不删除表结构 但TRUNCATE速度更快
	不同
	 使用TRUNCATE TABLE 重新设置 自动增长列(自增)(AUTO_INCREMENT计算器) 从零开始
	 使用DELETE 自增表会从删除前的自增数接着递增
	 TRUNCATE不支持回滚   DELETE可以回滚
	
```

#### DDL数据库定义语言(操作数据库、数据表)

##### 操作数据库

###### 刷新数据库

```
	
	FLUSH TABLES //刷新数据库 将所有数据写入 到数据库中
	
```

###### 连接数据库语句

```
	
	mysql -h 服务器主机地址 -u 用户名 -p用户密码

```

###### 创建数据库

```
	
	CREATE DATABASE 数据库名; //创建数据库
	CREATE DATABASE IF NOT EXISTS 数据库名; //创建数据库(判断不存在 不存在才创建)
	CREATE DATABASE 数据库名 CHARACTER SET 编码字符集名称; //创建数据库(指定编码字符集)
	
	//数据库名 由 字母和下划线组成 不允许有空格 可以是英文单词缩写 不是mysql关键字 长度最好不超128位
	
```

###### 查询(查看)数据库

```
	
	SHOW DATABASES; //查询所有数据库
	SHOW CREATE DATABASE 数据库名; //查询某个数据库的创造语句 //查询某个数据库的字符集
	
```

###### 修改数据库

```
	
	ALTER DATABASE 数据库名 CHARACTER SET 编码字符集名称; //修改数据库编码字符集
	
```

###### 删除数据库

```
	
	DROP DATABASE 数据库名; //删除数据库
	DROP DATABASE IF EXISTS 数据库名; //删除数据库(存在就删除)
	//在删除数据库前 先使用IF EXISTS语句验证库是否存在
	
```

###### 使用数据库(使用数据前必须先选择数据库)

```
	
	SELECT DATABASE(); //查询当前正在使用的数据库名
	USE 数据库名; //使用这个数据库
	
```

##### 操作数据表

###### 创建数据表		

```

	创建数据库表的步骤
	 确定表中有哪些字段
	 确定每字段的数据类型
	 给表添加各种约束
	 创建各表之间的关系
	 
	CREATE TABLE 表名(
		字段1 字段类型  [属性][索引(约束)][注释],
		字段2 字段类型  [属性][索引][注释],
		字段3 字段类型  [属性][索引][注释]
	)[表类型][表字符集][表注释];
	
	[表类型] ENGINE = 存储引擎类型(默认INNODB) 
	[表字符集] CHARSET = 编码字符集(默认安装选择的编码) 
	[表注释] COMMENT = 表注释 
	
	//最后一列 不需要","
	//属性和约束可以多个 通过空格隔开
	//MYSQL可以使用不同类型的存储引擎 来实现不同方式的数据储存和管理,常见的储存引擎MYISAM INNODB
	//表名 由 字母和下划线组成 不允许有空格 可以是英文单词缩写 不是关键字 长度最好不超128位 不可同库表名

```

###### 创建临时数据表保存查询结果

```
	
	第一种
	使用临时表保存查询结果
	CREATE TEMPORARY TABLE 表名 (查询语句);
	
	//临时表只在当前连接可见 连接关闭自动删除 修改临时表数据不影响原表数据
	
	第二种
	//在出现在FROM子句中 的子查询 必须指定表别名 一般返回多行多列数据记录 可以当做一张临时表
	
```

###### 修改数据表

```
	
	//有些更改替换的时候需要将 其它条件也指定 
	
	ALTER TABLE 表名 RENAME [TO] 新的表名; //修改表名
	//TO为可选参数 使用与否不影响结果
	
	ALTER TABLE 表名 CHARACER SET 编码字符集名; //修改表的编码字符集
	
	ALTER TABLE 表名 MODIFY 字段名 新数据类型; //修改字段类型
	ALTER TABLE 表名 CHANGE 字段名 新字段名 新数据类型; //修改字段名称 类型
	//如果不需要修改数据类型 则和原数据类型保持一致 但数据类型不能为空 
	//注意更改对数据长度或类型的影响 不符合数据类型的数据会被清空
	
	ALTER TABLE 表名 DROP 字段名; //删除该字段
	
	ALTER TABLE 表名 ADD 字段名 字段类型 [属性]; //在表的最后一列 添加一个字段(列)
	ALTER TABLE 表名 ADD 字段名 字段类型 [属性] FIRST; //在表的第一列 添加一个字段(列)
	ALTER TABLE 表名 ADD 字段名 字段类型 [属性] AFTER 字段名; //在该字段后 添加一个字段(列)
	
	ALTER TABLE 表名 MODIFY 字段名 字段类型 FIRST; //修改该字段为表的第一个字段
	ALTER TABLE 表名 MODIFY 字段名1 字段类型 AFTER 字段名2; //将 字段1 修改到 字段名2 后
	
	ALTER TABLE 表名 ENGING = 引擎名称; //更改表的引擎  //可以用 看创建表结构 查引擎
	
```

###### 查询(查看)数据表

```
	
	查看表之前要USE 对应数据库
	SHOW TABLES; //查询使用的数据库 的所有数据表
	DESC 表名; //查询表结构
	DESCRIBE 表名; //查询表结构 //一般情况下 DESC是DESCRIBE的简写
	
	SHOW CREATE TABLE 表名; //查询建表语句
	
```

###### 复制数据表

```

	CREATE TABLE 表名 LIKE 被复制的表名

```

###### 删除数据表

```
	
	DROP TABLE 表名; //删除数据表
	DROP TABLE 表名,表名,表名; //一次删除多个数据表
	DROP TABLE IF EXISTS 表名; //删除数据表(如果存在再删除)
	//在删除表前 先使用IF EXISTS语句验证表是否存在
	
	//删除被关联的表 有两种办法
		先把从表删了再删主表
		保留表数据 将外键删除
	
```

#### DCL数据控制语言(管理用户授权)

```
	
	DBA 数据库管理员
	DCL 管理用户 授权
	
```

##### 管理用户

```
	
	//@为固定格式 不是参数
	
	添加用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
	删除用户 DROP USER '用户名'@'主机名';
	修改用户密码
	 UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';
	 SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');
	查询用户
	 切换到mysql数据库 USE mysql;
	 查询user表 SELECT * FROM USER;
	 
```

##### 权限管理

```
	
	//@为固定格式 不是参数
	
	查询权限 
	 SHOW GRANTS FOR '用户名'@'主机名';
	 //其中主机名 可换为 % 表示可以在任意主机使用用户登录数据库 
	授予权限 权限用时百度
	 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
	 例 给xx用户授予所有权限 在任意数据库和任意表上
	 GRANT ALL ON *.* TO 'xx'@'localhost';
	撤销权限
	REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
	
```

#### SQL语句操作视图

##### 什么是视图

```
	
	视图充当着查询中指定表的筛选器
	视图是一张虚拟表
	 //表示一张表的部分数据或多张表的综合数据
	 //其结构和数据是建立在对表的查询基础上
	视图中不存放数据
	 //数据存放在视图所引用的原始表中
	一个原始表 根据不同用户的不同需求 可以创建不同的视图
	
```

##### 视图用途(视图的好处)

```
	
	//筛选表中的行
	//防止未经许可的用户访问敏感数据 保证信息安全
	//不同的人员关注不同的数据
	//降低数据库的复杂程度
	//将多个物理数据库抽象为一个逻辑数据库 可以跨库显示表
	
	对最终用户的好处
	 //结果更容易理解 获得数据更容易
	对开发人员的好处
	 //限制数据检索更容易 可以保证某些数据的安全性 将对用户保密的列排序在外
	 //维护应用程序更方便 跟踪每个表的错误更为容易
	
	//视图中可以使用多个表
	//实际开发中视图仅作查询
	//一个视图可以嵌套另一个视图 但最好不要超过三层
	//对视图数据进行添加、更新、删除操作 直接影响所引用表中的数据
	//当视图数据来自多个表时,不允许添加和删除数据
	//使用视图修改数据会有许多限制,一般在实际开发中视图仅用作查询
	
```

##### 视图与原始表的关系

```
	
	视图的数据来源于原始表 会随着原始表的值而改变
	如果视图只包括一张原始表则可以 对视图数据进行添加、更新、删除操作 直接影响所引用表中的数据
	视图可以跨库查询 可以连接多张表
	视图 在某种程度上也可以当做 一张表使用
	一张表可以创建多个视图 满足用户需求

```

##### 创建视图

```
	
	CREATE VIEW 视图名称 AS (SELECT查询语句);
	//可以给创建出来的视图 重新命名字段
	CREATE VIEW 视图名称(视图字段别名,...) AS (SELECT查询语句);
	//上面如果不能正确更改字段名 则通过SELECT查询将查询出来的字段用AS重命名 
	
	//在SQL语句命名规范中 视图一般以View_xxx 或 v_xxx 的样式来命名
	//多张表内容创建视图 SELECT查询语句使用内链接
	
```

##### 修改视图

```
	
	CREATE OR REPLACE VIEW 视图名称 AS (SELECT查询语句);
	OR
	ALTER VIEW 视图名称 AS (SELECT查询语句);
	//可以在SELECT查询语句 中使用别名 用于更改字段名称
	
```

##### 删除视图

```
	
	DROP VIEW 视图名称; //直接删除视图 可能出现错误
	DROP VIEW IF EXISTS 视图名称; //删除前判断视图是否存在
	
```

##### 查看视图基本信息

```
	
	DESC 视图名; //查看视图结构
	SHOW CREATE VIEW 视图名; //查看视图定义语句
	
```

##### 查看所有视图

```
	
	SELECT 字段1,字段2... FROM 视图名称;
	
	USE information_schema;
	SELECT * FROM views\G;
	
```

#### 字段的约束(属性)及索引

##### 约束

```mysql
	
	//通过约束 对表中的数据进行限定 保证数据的正确性 有效性 完整性
	
	非空约束		NOT NULL		  字段值不允许为空
	默认约束		DEFAULT   		  赋予某字段默认值
	唯一约束 		UNIQUE KEY(UK)     设置字段的值是唯一的 允许为空 但只能有一个null值  //创建了唯一约束 将自动创建唯一索引
	主键约束		PRIMARY KEY(PK)	   设置该字段为主键 可唯一标识该表记录
	外键约束		FOREIGN KEY(FK)	   用于在两表直接建立关系  需要指定引用主表的哪一字段
	数值属性		......  		  对储存的数据进行约束
	
	//多个约束直接 通过空格隔开
	//一个字段同时被NOT NULL 和 UNIQUE 约束 该字段自动变成主键字段
	
```

###### 非空约束

```
	
	//字段值不能为空	默认为NULL 即数据可以为空
	
	创建表时添加约束
	CREATE TABLE 表名 (
		字段名 字段数据类型 NOT NULL
	);
	删除非空约束
	ALTER TABLE 表名 MODIFY 字段名 字段类型;
	创建表之后 添加非空
	ALTER TABLE 表名 MODIFY 字段名 字段类型 NOT NULL;
	
```

###### 默认约束

```
	
	//DEFAULT 默认的
	//用于设置字段数据默认值
	//例如性别字段 值为"男" "女" 若无指定则默认为"男" 
	
	CREATE TABLE 表名 (
		字段名1 字段数据类型 DEFAULT "默认值"
		字段名2 字段数据类型 DEFAULT 0
	)
	
```

###### 唯一约束(索引)

```
	
	//设置字段的值是唯一的 允许为空 但只能有一个null值
	//唯一索引可有多个 但不要过多 影响 DML 操作性能
	//创建了唯一约束 将自动创建唯一索引
	
	创建表时添加约束
	CREATE TABLE 表名 (
		字段名 字段数据类型 UNIQUE KEY
		或
		字段名 字段类型 ...,
		UNIQUE KEY(字段名) -- 先创建字段之后指定主键 可以指定多个字段联合起来唯一UNIQUE KEY(字段名,字段名)
	)
	删除唯一约束
	ALTER TABLE 表名 DROP INDEX 字段名;
	创建表之后 添加唯一约束
	ALTER TABLE 表名 MODIFY 字段名 字段数据类型 UNIQUE；
	
```

###### 主键约束(索引)

```
	
	//非空 且 唯一
	//一张表只能有一个字段(或一个联合主键)为主键 
	//主键可以为多字段 和 单子段
	//所谓的一张表多个主键 我们称之为联合主键 用多个字段一起 作为一张表的主键
	//主键 保证数据 唯一性 完整性 同时通过主键检索表 增加检索速度
	//任何数据库中 主键 都会 自动添加 索引
	
//单字段主键
	创建表示添加主键约束
	CREATE TABLE 表名 (
		字段名 字段数据类型 PRIMARY KEY
		或
		字段名 字段类型 ...,
		PRIMARY KEY(字段名) -- 先创建字段之后指定主键
	)
//多字段主键
 	创建表示添加主键约束
	CREATE TABLE 表名 (
		字段名 字段数据类型 PRIMARY KEY
		或
		字段名1 字段类型 ...,
		字段名2 字段类型 ...,
		PRIMARY KEY(字段名1,字段名2) -- 先创建字段之后指定主键
	)
	删除主键
	ALTER TABLE 表名 DROP PRIMARY KEY;
	--错误 ALTER TABLE 表名 MODIFY 字段名 字段类型;
	创建表之后 添加主键
	ALTER TABLE 表名 MODIFY 字段名 字段类型 PRIMARY KEY;
	ALTER TABLE 表名 ADD CONSTRAINT 主键名 PRIMARY KEY 表名(主键字段);
	
```

###### 外键约束

```
	
	//让表于表产生关系 从而保证数据的正确性
	//外键可以不是 本表的主键 但会对应着另外一张数据表的 主键
	//用于在两表直接建立关系 需要指定引用主表的哪一字段
	//MyISAM不支持外键 可以通过建立逻辑关联的方式保证 数据的完整性和一致性 不需要再数据库层面进行 '硬绑定' 
	//表1称为主表 表2称为从表  主表和从表必须使用InnoDB引擎
	//一个表可以有零到多个外键 外键可以为空值 若不为空值 则每一个外键的值必须等于主表中主键的某个值
	//外键约束的字段 和关联的主键 必须具有相同的数据类型 整数类型的大小和符号必须相同 字符串的长度看可以不同 -(非二进制字符串字符集 和 排序顺序必须相同)
	//主表必须已经存在于数据库中 或者是当前正在创建的表 是后一种情况 则主表与从表是同一个表 这样的表称为自参照表 这种结构称为自参照完整性
	//必须为主表定义主键 主键不能包含空值 但允许在外键中出现空值
	
	
	CREATE TABLE 表名1 (
		字段名1 字段数据类型 PRIMARY KEY, --主表的主键
	);
	
	CREATE TABLE 表名2 (
		字段名2 字段数据类型, --从表需要设置外键约束的字段
		CONSTRAINT 外键名称 FOREIGN KEY (字段名2) REFERENCES 库名.主表名 (字段名1)
		//外键名称 一般为FK_xx 用于区别 和 防重
	);
	
	//[CONSTRAINT <外键名>] FOREIGN KEY 字段名 [,字段名2,…] REFERENCES <库名.主表名> 主键列1 [,主键列2,…]
	
	
	删除外键
	ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
	创建表之后 添加外键
	ALTER TABLE 主表表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(本表外键字段名称) REFERENCES 做为外键表名称(做为外键表字段名称);
	
```

##### 索引

```
	
	索引是一种有效组合数据的方式 为快速查找到指定记录 可以快速查找所需信息 无须读取全部数据
	
	//提高数据库检索速度  //改善数据性能
	//唯一性比较弱的 字段创建索引 用处不大
	
	索引按储存类型分类 
	B-树索引 INNODB、MyISAM
	哈希索引 MEMORY
	
	索引类型 
	普通索引 唯一索引 主键索引 复合索引 全文索引 空间索引
	
	常规索引 		 INDEX / KEY        快速定位特定数据
	全文索引         FULLTEXT		    快速定位特点数据 //只能用于MyISAM
	唯一约束(索引)    UNIQUE KEY(UK)     设置字段的值是唯一的 允许为空 可以有多个null //自动创建唯一索引
	主键约束(索引)    PRIMARY KEY(PK)	   设置该字段为主键 可唯一标识该表记录 //自动创建主键索引
	
```

###### 概念理解

```
	
	对于一本字典来说 查找汉字有两种方法
	
	第一种 
		一个字一个字挨着找
		
	第二种
		先通过目录(索引) 定位一个大概的位置 然后定位到这个位置 做局域性扫描 缩小扫描的范围 快速的查找 通过索引检索 效率高
		//只有排序了才有区间查找 mysql的索引也需要排序的 这个排序和TreeSet(是一个自平衡的二叉树)数据结构相同 在mysql中索引时一个B-Tree 数据结构
	
	//MYSQL 在查询方面 只要是 两种方式 全表扫描(根据查找条件) 和 根据索引检索
	//MYSQL索引的底层是b_tree
	//索引是各种 数据库进行优化的 重要手段 优化优先考虑的因素就是索引
	
```

###### 创建索引原则

```
	
	//不要随便添加索引 因为索引也是需要维护的
	
	可添加索引的列 
		频繁搜索 经常用作查询选择的列 数据量比较庞大
		经常排序、分组的列
		经常用作连接的列(主键/外键)
		DML(增删改)很少 进行DML后索引需要重新排序
	
	
	不要在以下的列创建索引
		仅包含几个不同值的列
		表中仅包含几行
	
	查询时
		减少*返回全部列 不要返回不需要的列
		多使用 主键 唯一约束的列进行查询 效率比较高
		索引应该尽量小 在字节数小的列上建立
		WHERE子句中有多个条件表达式时 包含索引的表达式应置于其他条件之前
		避免在ORDER BY子句中使用表达式
		根据业务数据发生频率 定期生成或重新组织索引 进行碎片索引
	
```

###### 创建索引

```
	
	在已有的表上创建索引
        CREATE (UNIQUE|FULLTEXT|SPATIAL可选) INDEX 索引名 ON 表名(索引字段);
            //创建索引其实就是 创建一个该字段底层的二叉树 查找物理地址 之后通过物理地址进行区域搜索  
            //索引名称命名方式 为 表名_字段名_index

        CREATE (UNIQUE|FULLTEXT|SPATIAL可选) INDEX 索引名 ON 表名(索引字段，索引字段...);
        	//两个或以上的字段 联合起来添加一个索引 叫做复合索引
        
        
        ALTER TABLE 表名 ADD (UNIQUE|FULLTEXT|SPATIAL可选) INDEX 索引名(索引字段);
        	//ALTER TABLE语句也可以
	
	可以在创建表的时创建索引
        CREATE TABLE 表名(
            字段1 字段类型,
            INDEX(或KEY) 索引名(索引字段)
        );
	
```

###### 删除索引

```
	
	DROP INDEX 索引名 ON 表名;
	或
	ALTER TABLE 表名 DROP INDEX 索引名;
	
	//ALTER TABLE 表名 DROP PRIMARY KEY; //可以删除主键索引
	
	//删除表 该表的索引同时会被删除
	
```

###### 查看索引

```
	
	SHOW INDEX/KEYS FROM 表名; //注意为keys  --查看表的索引信息
	
```

###### 查看查询是否使用索引

```
	
	explain SELECT * FROM x WHERE... 
	
	//type 是ref表示使用索引 rows表示搜索了几行搜寻到 增加了索引的列 查找速度会非常诡异
		
```

###### 索引的失效

```
	
	//索引有失效的时候 有以下几种失效原因 可以将此看成一种优化的手段
	//以下 字段1都有索引 字段2不具有索引 字段3字段4创建复合索引(3在左侧 4在右侧)
	
	第一种
		SELECT * FROM 表名 WHERE 字段1 like '%x';
		//原因是因为模糊匹配中 以 % 开头了 
		//尽量避免 模糊查询以%开始 
		
	第二种
		SELECT * FROM 表名 WHERE 字段1="x" or 字段2="x";
		//原因是 如果使用or 那么 or 两边的条件字段 都要有索引 
		//不建议使用or 提倡使用IN关键字
		
	第三种
		SELECT * FROM 表名 WHERE 字段3="x"; //使用了索引
		SELECT * FROM 表名 WHERE 字段4="x"; //没有使用索引
		//使用复合索引 没有使用左侧的列查找
		
		B+树 的最左原则 复合索引比如是 (字段A,字段B,字段C) 从左到右建树 查找的时候比如条件是 x,1,20 那么会先找所有字段A是x的记录 再在这些记录中查找字段B=1的记录 之后 再在这些记录中查找字段C=20的记录 如果查找条件是（字段B,字段C)那么索引就会失效
		//可以使用索引的查询条件为(字段A)(字段A,字段B)(字段A,字段B,字段C)
		
	第四种
		SELECT * FROM 表名 WHERE 字段1+1 = "x";
		//在WHERE中 索引列参加了运算
		
	第五种
		SELECT * FROM 表名 WHERE lower(字段1) = 'x';
		//在WHERE中 索引列使用了函数
		
	等等
	
```

###### 常规索引

```
	
	//快速定位特定数据
	//INDEX 和 KEY关键字都可以设置常规索引
	//应该添加在查找条件的字段
	//不易添加太多常规索引,影响数据的插入、删除和修改操作
	//索引不是越多越好 
	//不要对经常变动的数据加索引
	//小数据量的表建议不要加索引
	//索引一般应加在查找条件的字段
	
	创建表时添加约束
	CREATE TABLE 表名 (
		字段名1 字段数据类型, 
		字段名2 字段数据类型, --字段名1 2 有查找相互关系
		INDEX/KEY "常规索引的名字" (字段名1,字段名2)
	)
	创建表之后 添加常规约束
	ALTER TABLE 表名 ADD INDEX/KEY "常规索引的名字" (字段名1,字段名2);
	
```

###### 全文索引

```
	
	//快速定位特定数据
	//只能用于MyISAM类似的数据表
	//只能用于CHAR VARCHAR TEXT 数据列类型
	//适合大型数据集
	
	创建表时添加全文约束
	CREATE TABLE 表名(
		字段名1 字段数据类型,
		FULLTEXT(字段名1)
	)ENGINE = MYISAM;
	创建表之后 添加全文约束
	ALTER TABLE 表名 ADD FULLTEXT(设置全文索引的字段);
	
```

##### 数值属性(数据类型属性)

###### 无符号属性

```
	
	UNSIGNED 属性
	
	 //标识为无符号数 无符号的
     //数据不能为负数
	
	CREATE TABLE 表名 (
		字段名 字段数据类型 UNSIGNED
	 );
	
```

###### ZEROFILL 属性

```
	
	 //数据不足位数以0填充 数值位数大于,以实际位数显示 //宽度(位数) //0填充的
	 //若某数值字段指定了ZEROFILL属性,将自动添加UNSIGNED属性
	 
	 CREATE TABLE 表名 (
		字段名 字段数据类型 ZEROFILL(*) //*为数字位数
		//如果不指定 * 使用类型的默认宽度 但是显示的宽度比默认宽度小1 因为默认宽度里面负号占了一位
	 )
	 
	 添加ZEROFILL
	 ALTER TABLE 表名 MODIFY 字段名 字段类型 ZEROFILL;
	
```

######  自动增长属性

```
	
	AUTO_INCREMENT  	自动增长属性
	
	//自动增长  每添加一条数据 字段在上一个条的记录上加1
    //某一列是数值类型的 可通过设置此完成值的自动增长
    //通常设置主键 且为整数类型 可定义起始值和步长
	
	创建表 添加主键约束 并设置自增长
	CREATE TABLE 表名 (
		字段名 字段数据类型 PRIMARY KEY AUTO_INCREMENT
	)
	
	添加自动增长
	ALTER TABLE 表名 MODIFY 字段名 字段类型 AUTO_INCREMENT;
	
	删除自动增长
	ALTER TABLE 表名 MODIFY 字段名 字段类型;
	
```

###### 表注释和字段注释

```
	
	CREATE TABLE 表名 (
		字段名 字段数据类型 COMMENT "注释"
	)COMMENT = "表注释"
	
```

#### 事务处理(使用事务时应先关闭自动提交)

##### 事务的描述(概念)

```mysql
	
	事务
	 //如果 一个包含多个 步骤的 业务操作 被事务管理 那么这些操作要么同时成功 要么同时失败
	 //事务就是将一组SQL语句放在同一批次内去执行  (作为单个逻辑工作单元执行的一系列操作)
	 //如果一个SQL语句出错 则该批次内所有SQL都将被取消执行
	 //MySQL事务处理只支持 INNODB 和 BDB 数据表类型
	 //只有DML语句才有事务 其它语句无关
	
	A原子性		事务是一个完整的操作 事务的各步操作时不可分的(原子的) 要么都执行 要么都不执行
	 //是不可分割的最小操作单位 要么同时成功 要么同时失败
	 
	C一致性		当 事务没开始时 事务完成时 数据必须处于一致状态	
	 //事务操作前后 数据总量不变  数据必须处于一致状态
	
	I隔离性		并发事务之间 彼此 隔离、独立、它不应以任何方式依赖于或影响其他事务	
	 //多个事务之间相互独立
	 //如果任何其他进程正在使用相同的数据 则直到该事务成功提交之后 对数据的修改才能生效 暂时挂起
	 //两个不同用数据的事物 永远是相互独立的
	
	D持久性		事务完成后 他对数据库的修改被永久保持	
	 //事务提交或回滚后 数据库会持久化的保存数据
	 //它对系统的改变是永久性的即使系统出现故障也是如此
	
```

##### 编写事务遵循原则

```
	
	事务尽可能简短
	 //事务启动至结束后在数据库管理系统中保留大量资源 以保证事务的原子性 一致性 隔离性 持久性
	 //如果用户在多用户系统中 较大的事务将会占用系统的大量资源 使得系统不堪重负 会影响软件的运行性能 甚至系统崩溃
	事务中访问的数据量尽量最少
	 //当并发执行事务处理时 事务操作的数据量越少 事务之间对操作数据的争夺就越少
	查询数据时尽量不要使用事务
	 //对数据进行浏览查询操作并不会更新数据库的数据 尽量不使用事务查询数据 避免占用过量系统资源
	在事务处理过程中尽量不要出现等待用户输入的操作
	 //在处理事务的过程中 如果需要等待用户输入数据 会长时间占用资源 有可能造成系统阻塞
	
```

##### 事务实际操作

```mysql
	
		关闭自动提交 SET AUTOCOMMIT = 0;
	
	操作
		开启事务     START TRANSACTION; 或 BEGIN; 
		回滚(撤销)   ROLLBACK; 发现出问题了 取消这次事务处理 回滚事务 //回滚永远只能回滚到上一次的提交点
		提交		  COMMIT;  //执行没有问题 提交事务
		
		例  以下 操作1,2 全部操作 执行COMMIT; 句后将正常操作 (其中一个没有完成 不进行事务操作)
		 START TRANSACTION; //开启事务
		 操作1; 
		 操作2;
		 COMMIT; //结束事务
	
		还原数据库的自动提交 SET AUTOCOMMIT = 1;
		
		//ROLLBACK 清除自事物起点至该语句所做的所有数据更新操作 将数据状态回滚到事务开始之前 并释放由事务控制的资源
		
		设置事务回滚点 SAVEPOINT 名字
		回到回滚点  ROLLBACK TO 名字
		
```

##### 事务提交的两种方式(关闭开启自动提交)

```mysql
	
	！！！//注意操作数据更改完成后 要开启自动提交
	
	 事务提交的两种方式
	  自动提交
	    MYSQL默认自动提交 //一条DML(增删改)语句会自动提交一次事务
	  手动提交
	  	Oracle数据库默认是手动提交事务的 //需要先开启事务 再提交
	 修改事务的默认提交方式
	   查看事务的默认提交方式 SELECT AUTOCOMMIT; 1开启自动提交 0关闭自动提交(手动提交)
	   修改默认提交方式 SET AUTOCOMMIT = 1;
	
	//在自动提交模式下 可以使用Commit来提交你的更改
	//在自动提交模式下 可以使用RollBack来回滚你的更改
	
```

##### 事务的隔离级别(了解)

```mysql
	
	多个事务之间隔离的 相互独立的
	但是如果多个事务操作同一批数据 则会引发一些问题 设置不同的隔离级别就可以解决这些问题
	
	存在问题
	 脏读 //一个事务A 可以读取到另一个事务B中 没有提交的数据
	 不可重复读(虚读)  //在同一个事务中 两次读取到的数据不一样 //但是每一次读到的数据是绝对的真实
	 可重复读 //事务开启之后 不管是多久只要事务没有结束 每一次在事务中读取到的数据都是一致的 
	 幻读 //一个事务A操作数据表中记录 另一个事务B添加了一条数据 第一个事务A查询不到事务B的修改
	
	查看隔离级别
	 select  @@tx_isolation;
	设置隔离级别
	 set global transaction isolation level 级别字符串;
	
	 隔离级别 (从小到大) //隔离级别从小到大安全性越来越高 但是效率越来越低
	  read uncommitted //读未提交 一般没人用
	  //产生问题 脏读
	  
	  read committed //读已提交  Oracle默认
	  //解决 脏读 产生问题 不可重复读
	  
	  repeatable read //可重复读  MySQL默认
	  //产生问题 幻读
	  
	  serializable //串行化 序列化
	  //可以解决所有的问题 事务排队 不能并发
	
```

### 数据库设置字符编码集

```
	
	//可为数据库、数据表、数据列指定不同的字符编码集
	CREATE TABLE 表名 (
		字段名 字段类型 CHARACTER SET 字符集名,
		...
	)CHARSET = 字符集名;
	
	//如果无设定,则根据MySQL数据库配置文件my.ini中的参数设定
	character-set-sever = utf8
	
```

### 数据库的储存引擎(表)

```
	
	储存引擎的类型
	MyISAM InnoDB Memory CSV 等9种
	
	默认储存引擎 在my.ini配置文件
	default-storage-engine = 引擎类型
	
	//一个库中的表可以单独设置不同的数据库引擎
	
	设置表的储存引擎
	 CREATE TABLE 表名(
	 	...
	 )ENGINE = 储存引擎
	 
	 数据储存位置
	 //储存位置 查找my.ini
	datadir="..."
	innodb_data_home_dir="..."
	
	查询当前默认的储存引擎
	SHOW VARIABLES LIKE "storage_engine%";
	
```

#### MyISAM

```
	
	事物处理	数据行锁定	外键约束	全文索引	表空间大小
	不支持		 不支持	   不支持	    支持        较小
	
	//不需要事物 空间小 以查询访问为主
	//可以转换为压缩 只读表节省空间 
	//节约空间及相应速度
	//访问速度比较快 以访为主的应用适合使用该引擎
	//多版本(MVCC) 行级锁定
	
	MyISAM类型表文件
	.frm //表结构定义文件
	.MYD //数据文件 储存表行的内容
	.MYI //索引文件 
	
```

#### InnoDB

```
	
	事物处理	数据行锁定	外键约束	全文索引	表空间大小
	支持		 支持	   		支持	      不支持      较大约为MyISAM 的2倍
	
	//多删除 更新操作频繁 安全性高 事务处理及并发控制的应用场合
	//不能很好的节省存储空间
	
	InnoDB数据表文件
	.frm //表结构定义文件
	ibdata1 //数据文件
	
```

#### MEMORY

```
	
	将数据储存到内存中 太大的表 无法使用
	
	//数据更新不频繁 存活周期不长 需要对统计结果进行分析
	//查询效率是最高的 因为在内存中 是电流的速度
	//行的长度固定 不能包含TEXT 或 BLOB字段
	//不安全 关机之后数据消失
	//每个表均以.frm格式的文件表示
	//表级锁机制
	
```

### 数据库的备份和还原

#### 备份(命令行备份)

```
	
	mysqldump [选项参数] -u用户名 -p密码 数据库名称 [该数据库下的表...省略备份所有表] > 保存的路径\备份后的文件名.sql
    
    //选取表时不包含 [] 表名用空格隔开
    //为保证密码安全 -p后面一般第一次不填 之后询问后有掩码之后再填写
    //属于DOS命令 使用时无需进入MySQL命令行 否则无法执行
    //会将CREATE 和 INSERT INTO 语句保存到文本文件 .sql
    //路径必须为绝对路径 而且是 mysql用户有权限访问的文件
    
    选项参数(了解)
     --add-drop-table
     //在每个CREATE TABLE语句前添加DROP TABLE语句 默认是打开的 可以用-skip-add-drop-table来取消
 	--add-locks
	//该选项会在INSERT 语句中捆绑一个LOCK TABLE 和UNLOCK TABLE 语句
	//防止记录被再次导入时 其他用户对表进行的操作
	-t或-no-create-info
	//只导出数据 而不添加CREATE TABLE语句
	-c或--complete-insert
	//在每个INSERT语句的列上加上列名 在数据导入另一个数据库时有用
	-d或--no-data
	//不写表的任何行信息 只转储表的结构

	备份文件 包含的主要信息
	//以 -- 开头 关于SQL语句的注释信息
	//以/*! 开头 */ 结尾 关于Mysql服务器相关的注释 可以被SQL服务器执行 但是其他数据库管理系统将被作为注释忽略 可以提高数据库的可移植性
	//备份账户名称
	//主机信息
	//备份数据库名称
	//SQL语句注释和服务器相关注释
	//CREATE 和 INSERT语句
	//MySQL 和 mysqldump 工具版本号
			
```

#### 还原

```
	
第一种	
	使用mysql命令恢复数据库
	
	mysql -u用户名 -p密码 数据库名 < 备份的路径\备份文件名.sql
	
	//DOS命令
	//路径必须为绝对路径 而且是 mysql用户有权限访问的文件
	//在执行该语句之前 必须在MySQL服务器中创建新数据库 如果不存在 恢复数据库过程将会出错
	
	登录数据库
    创建数据库
    使用数据库
    执行文件 source 文件路径mysql命令恢复
	
第二种
	使用SOURCE 命令恢复数据库
	
	SOURCE 备份的路径\备份文件名.sql;
	
	//MySQL命令行 需要登录MySQL使用
	//路径必须为绝对路径 而且是 mysql用户有权限访问的文件
	//执行该命令前 先创建 并选择恢复后的目标数据库
	
```

#### 备份还原(通过复制备份 粘贴替换还原)

```
	
	//不是最优的数据库备份和恢复方案
	//优点操作简单
	//复制数据前停止服务
	//不适合INNERDB数据库
	//MySQL版本不同不兼容
	
	直接复制MySQL数据库的储存目录 文件进行备份 
	
```

#### 备份(二进制日志恢复数据)

```
	
	开启二进制日志后 系统会自动记录用户执行的数据更新操作 可以使用mysqlbinlog命令恢复数据
	
	mysqlbinlog 二进制日志文件名 | mysql -u 用户名 -p 密码 //包含'|' DOS命令 
	
	SET SQL_LOG_BIN = 0; //暂停二进制日志 1为开启 
	
```

#### 导出导入数据进行 数据转移

```
	
	//可以实现服务器间数据移动
	
	导出
		SELECT * FROM 导出表名 [WHERE 可选备份数据] INTO OUTFILE '[路径]/导出的目标文件.txt';
			//导出的数据用空格分隔 例 1 xxx 18 1977-10-22
		
		//可以使用FIELDS 参数 定义分隔符 和 包裹数据的符号 等 下面语句为一句话
		SELECT * FROM 导出表名 [WHERE 可选备份数据] INTO OUTFILE '[路径]/导出的目标文件.txt' FIELDS TERMINATED BY ',' ENCLOSED BY '\"' ESCAPED BY '\'' LINES TERMINATED BY '\r\n';
			//导出的数据用,分隔 用双引号扩起 例 "1","xxx","18","1977-10-22"
			//STARTING　BY ',' 制定每行开始的标志 默认不使用任何字符
			//TERMINATED BY ',' 字段之间用,分隔 
			//ENCLOSED BY '\"' 字段用双引号括起来
			//ESCAPED BY '\'' 将系统默认的转义字符替换为单引号
			//LINES TERMINATED BY '\r\n' 每行以回车换行符结尾
			
			
		mysqldump,mysql //语句也可以导出文本文件 mysql可以将记录到处为html或xml文件 具体使用百度
		 
	
	导入
		LOAD DATA INFILE '[路径]/导入的目标文件.txt' INTO TABLE 表名;
		
		//也可带有FIELDS 参数
		//[IGNORE 忽略的行数 LINES] 可选 忽略文件开始处的行数
		LOAD DATA INFILE '[路径]/导入的目标文件.txt' INTO TABLE 表名 FIELDS ... [IGNORE 忽略的行数 LINES];
		
		mysqldump //也可导入文本文件
	
	//导入前确保目标表已存在
	//路径必须为绝对路径 而且是 mysql用户有权限访问的文件
	
```

### 数据库日志管理

#### 错误日志

```
	
	重要的日志之一 在服务 开启和结束时 发生故障时可以查看该日志
    	//默认开启(且该日志类型无法被阻止) 
    	//位置在data目录下 文件名为 服务器主机名.err
    	//可以根据my.ini文件定义 日志名称位置 在[mysqld]组下 log_error = [path/[文件名]]
    	//SHOW VARIABLES LIKE 'log_error'; 查询错误日志存储路径
   
```

####  二进制文件

```
	
	记录了所有DDL和DML 不包含查询语句 记录了发生时间 执行时长 操作的数据
		//默认关闭
		//位置在data目录下 文件名为 .000001(服务每重启会增加一个该文件 后缀会递增1) 和 .index的两个文件 
		//可以将二进制文件放在不同的磁盘 发生故障时可以使用二进制文件恢复
		//可以根据my.ini文件定义 日志名称位置 在[mysqld]组下 log_bin = [path/[文件名]] 且需要指定server_id = 1(5.7.3版本后的要求) 可再配置 [expire_logs_days=过期天数默认0] 和 [max_binlog_size=单个日志文件大小默认1GB] 
		//SHOW VARIABLES LIKE '%bin%'; 查询二进制日志存储路径
		//因为是二进制文件所以不能直接读取 需要使用mysqlbinlog命令查看 
			mysqlbinlog(DOS命令) 文件目录(后缀为.00000x);
		//删除所有二进制文件 
			RESET MASTER;
	
```

#### 通用查询日志

```
	
	记录服务器接收的每一个查询或命令(不管是否包含结果 或 语法是否错误)
		//默认关闭 会产生很大系统开销
		//[mysqld]组下 general_log=1 开启 0为关闭
		//general_log_file = [path/[文件名]] 设置名称位置
		////SHOW VARIABLES LIKE '%general%'; 查询通用日志存储路径
	
```

#### 慢查询日志

```
	
	//[mysqld]组下 slow_query_log=1 开启 0为关闭
	//后缀为log 可以直接打开
	
```

### 数据库系统帮助

```
	
	HELP 查询内容;
	
```

## 待处理(备份)

```
	
	级联操作
		 添加级联操作
			 语法: ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE;
		 分类
			 级联更新: ON UPDATE CASCADE 
			 级联删除: ON DELETE CASCADE 
	
```

